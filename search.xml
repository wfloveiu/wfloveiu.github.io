<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux虚拟内存管理(源码阅读1)</title>
      <link href="/2023/12/25/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1)/"/>
      <url>/2023/12/25/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1)/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用虚拟内存"><a href="#为什么使用虚拟内存" class="headerlink" title="为什么使用虚拟内存"></a>为什么使用虚拟内存</h2><p>一句话：引入虚拟内存后，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的。</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251453156.png" alt="640"></p><h2 id="虚拟内存地址格式"><a href="#虚拟内存地址格式" class="headerlink" title="虚拟内存地址格式"></a>虚拟内存地址格式</h2><p>都以4K为基本页框大小</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251455900.png" alt="image-20231225145536867"></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251455383.png" alt="image-20231225145517347"></p><h2 id="进程的虚拟内存空间"><a href="#进程的虚拟内存空间" class="headerlink" title="进程的虚拟内存空间"></a>进程的虚拟内存空间</h2><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251458277.png" alt="640 (1)"></p><ul><li>用于存放进程程序二进制文件中的机器指令的代码段</li><li>用于存放程序二进制文件中定义的全局变量和静态变量的数据段和 BSS 段。其中数据段中为指定了初始值的全局变量和静态变量；BSS段中为为指定初始值的全局变量和静态变量（初始化为0）</li><li>用于在程序运行过程中动态申请内存的堆。堆空间中地址的增长方向是从低地址到高地址增长。</li><li>用于存放动态链接库以及内存映射区域的文件映射与匿名映射区。</li><li>用于存放函数调用过程中的局部变量和函数参数的栈。</li></ul><h3 id="虚拟内存空间分布"><a href="#虚拟内存空间分布" class="headerlink" title="虚拟内存空间分布"></a>虚拟内存空间分布</h3><p>虚拟内存空间包括用户态和内核态。</p><h4 id="32位机器"><a href="#32位机器" class="headerlink" title="32位机器"></a>32位机器</h4><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251503730.png" alt="640 (2)"></p><p>用户态虚拟内存空间中的代码段并不是从 0x0000 0000 地址开始的，而是从 0x0804 8000 地址开始。</p><p>0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段不可访问的保留区，因为在大多数操作系统中，数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的。比如在 C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。</p><p>BSS 段的上边就是我们经常使用到的堆空间，从图中的红色箭头我们可以知道在<strong>堆空间中地址的增长方向是从低地址到高地址增长</strong>。</p><p>内核中使用 start_brk 标识堆的起始位置，brk 标识堆当前的结束位置。当堆申请新的内存空间时，只需要将 brk 指针增加对应的大小，回收地址时减少对应的大小即可。比如当我们通过 malloc 向内核申请很小的一块内存时（128K 之内），就是通过改变 brk 位置实现的。</p><p>堆空间的上边是一段待分配区域，用于扩展堆空间的使用。</p><p>接下来就来到了文件映射与匿名映射区域。<strong>在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长</strong>。</p><p>接下来用户态虚拟内存空间的最后一块区域就是栈空间了，在这里会保存函数运行过程所需要的局部变量以及函数参数等函数调用信息。<strong>栈空间中的地址增长方向是从高地址向低地址增长</strong>。</p><p>在内核中使用 start_stack 标识栈的起始位置，RSP 寄存器中保存栈顶指针 stack pointer，RBP 寄存器中保存的是栈基地址。在栈空间的下边也有一段待分配区域用于扩展栈空间。</p><h4 id="64位机器"><a href="#64位机器" class="headerlink" title="64位机器"></a>64位机器</h4><p>虽然64位机器的指针寻址范围是2^64,但是在目前的 64 位系统下只使用了 <strong>48 位来描述虚拟内存空间</strong>，寻址范围为  2^48 ，所能表达的虚拟内存空间为 256TB。</p><p>其中低 128 T 表示用户态虚拟内存空间，虚拟内存地址范围为：0x0000 0000 0000 0000  - 0x0000 7FFF FFFF F000 。</p><p>高 128 T 表示内核态虚拟内存空间，虚拟内存地址范围为：0xFFFF 8000 0000 0000  - 0xFFFF FFFF FFFF FFFF 。</p><p>这样一来就在用户态虚拟内存空间与内核态虚拟内存空间之间形成了一段 0x0000 7FFF FFFF F000  -  0xFFFF 8000 0000 0000  的地址空洞，我们把这个空洞叫做 canonical address 空洞</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251733199.png" alt="640 (4)"></p><p>如上图，还可以看到：在代码段跟数据段的中间还有一段不可以读写的保护段，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。</p><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间全部是一样的。</p><p>直接看参考文献第7节吧：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21#wechat_redirect">参考文献</a></p><h2 id="进程虚拟内存空间的管理"><a href="#进程虚拟内存空间的管理" class="headerlink" title="进程虚拟内存空间的管理"></a>进程虚拟内存空间的管理</h2><p>内核中的进程描述符<code>task_struct</code>结构</p><p>在  <code>include/linux/sched.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">// 进程id</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 进程打开的文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>  *<span class="title">files</span>;</span></span><br><span class="line">    <span class="comment">// 该进程的虚拟地址空间结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在<code>include/linux/mm_types.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;  <span class="comment">// 用户态和内核态的分界线</span></span><br><span class="line">    <span class="comment">// 使用如下属性定义虚拟内存中的不同区域</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;  <span class="comment">/* base of mmap area */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm;    <span class="comment">/* Total pages mapped */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_vm;  <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pinned_vm;  <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data_vm;    <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> exec_vm;    <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm;    <span class="comment">/* VM_STACK */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>task_size定义了用户态地址空间与内核态地址空间之间的分界线。32 位系统中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。32 位系统中task_size 为 0xC000 000。同理，64 位系统中用户地址空间和内核地址空间的分界线在  0x0000 7FFF FFFF F000 地址处，那么自然进程的 mm_struct 结构中的 task_size 为 0x0000 7FFF FFFF F000 。</p><p>start_code 和 end_code 定义代码段的起始和结束位置，start_data 和 end_data 定义数据段的起始和结束位置；start_brk 定义堆的起始位置，brk 定义堆当前的结束位置，start_stack 是栈的起始位置在RBP寄存器中，栈的结束位置也就是栈顶指针 stack pointer 在 RSP 寄存器中存储；arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。它们都位于栈中的最高地址处；mmap_base 定义内存映射区的起始地址</p><p>还定义了一些虚拟内存与物理内存映射内容相关的统计变量。</p><p>mm_struct 结构体中的 total_vm 表示在进程虚拟内存空间中总共与物理内存映射的页的总数。</p><p>当内存吃紧的时候，有些页可以换出到硬盘上，而有些页因为比较重要，不能换出。locked_vm 就是被锁定不能换出的内存页总数，pinned_vm  表示既不能换出，也不能移动的内存页总数。</p><p>data_vm 表示数据段中映射的内存页数目，exec_vm 是代码段中存放可执行文件的内存页数目，stack_vm 是栈中所映射的内存页数目，这些变量均是表示进程虚拟内存空间中的虚拟内存使用情况。</p><p>下图为一个总览图：</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251733977.png" alt="640 (5)"></p><h3 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h3><p>内核中使用结构体 <code>vm_area_struct</code>，来管理像代码段、数据段等不同的虚拟内存区域VMA</p><p>同样在<code>include/linux/mm_types.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*定义虚拟内存区域起始地址*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">    /*省略*/</span></span><br><span class="line">    <span class="comment">/*定义访问权限*/</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span> <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>  <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;  <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>vm_start 指向了这块虚拟内存区域的起始地址（最低地址），vm_start 本身包含在这块虚拟内存区域内。vm_end 指向了这块虚拟内存区域的结束地址（最高地址），而 vm_end 本身包含在这块虚拟内存区域之外，所以 vm_area_struct 结构描述的是 [vm_start，vm_end) 这样一段左闭右开的虚拟内存区域。</p><p>vm_page_prot 和 vm_flags 都是用来标记 vm_area_struct 结构表示的这块虚拟内存区域的访问权限和行为规范。</p><p>接下来的三个属性 anon_vma，vm_file，vm_pgoff 分别和虚拟内存映射相关，虚拟内存区域可以映射到物理内存上，也可以映射到文件中，映射到物理内存上我们称之为匿名映射，映射到文件中我们称之为文件映射。</p><p>当我们调用 malloc 申请内存时，如果申请的是小块内存（低于 128K）则会使用 do_brk() 系统调用通过调整堆中的 brk 指针大小来增加或者回收堆内存。</p><p>如果申请的是比较大块的内存（超过 128K）时，则会调用 mmap 在上图虚拟内存空间中的文件映射与匿名映射区创建出一块 VMA 内存区域，如果进行匿名映射，其匿名映射区域就用 struct anon_vma 结构表示；如果进行文件映射，vm_file 属性就用来关联被映射的文件，vm_pgoff 则表示映射进虚拟内存中的文件内容，在文件中的偏移。</p><h3 id="将虚拟内存区域组织进虚拟内存中"><a href="#将虚拟内存区域组织进虚拟内存中" class="headerlink" title="将虚拟内存区域组织进虚拟内存中"></a>将虚拟内存区域组织进虚拟内存中</h3><p><strong>同一个进程的虚拟内存空间的不同虚拟内存区域是如何组织起来的呢？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span>  <span class="comment">//红黑树节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内核中使用两种方式对虚拟内存区域进行组织</p><p>一是通过一个 struct vm_area_struct 结构的<strong>双向链表</strong>将虚拟内存空间中的这些虚拟内存区域 VMA 串联起来的。</p><p>vm_area_struct 结构中的 vm_next ，vm_prev 指针分别指向 VMA 节点所在双向链表中的后继节点和前驱节点，内核中的这个 VMA 双向链表是有顺序的，所有 VMA 节点按照低地址到高地址的增长方向排序。双向链表中的最后一个 VMA 节点的 vm_next 指针指向 NULL，双向链表的头指针存储在内存描述符 struct mm_struct 结构中的 <strong>mmap</strong> 中，正是这个 mmap 串联起了整个虚拟内存空间中的虚拟内存区域。</p><p>二是为了高效查询，将VMA作为红黑数的节点，以红黑树来组织。</p><p>每个 VMA 区域都是红黑树中的一个节点，通过 struct vm_area_struct 结构中的 vm_rb 将自己连接到红黑树中。而红黑树中的根节点存储在内存描述符 struct mm_struct 中的 <strong>mm_rb</strong> 中</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251734943.png" alt="640 (6)"></p><p>参考文献：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21#wechat_redirect">参考文献</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux内核源码阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2023/12/14/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2023/12/14/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><a href="https://www.cnblogs.com/alantu2018/p/8612722.html">内容介绍</a></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INEF,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">//服务器端监听套接字</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr)); <span class="comment">//初始化addr_in类型</span></span><br><span class="line">addr.sin_family = AF_INET; <span class="comment">//IPV4</span></span><br><span class="line">addr.sin_port = hton(<span class="number">2000</span>);<span class="comment">//端口2000</span></span><br><span class="line">addr_sin_addr.s_addr = INADDR_ANY; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)); <span class="comment">//绑定陶套接字和套接口地址</span></span><br><span class="line">listen(socfd, <span class="number">5</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client,<span class="number">0</span>,<span class="keyword">sizeof</span>(client)); <span class="comment">//初始化客户端套接字</span></span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    fds[i] = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; max)</span><br><span class="line">        max = fds[i];<span class="comment">//记录最大的文件描述符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fd_set rset;</span><br><span class="line">    FD_ZERO(&amp;rest); <span class="comment">//全部置为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        FD_SET(fds[i],&amp;rset); <span class="comment">//将我们关心的文件描述符设为1</span></span><br><span class="line">    </span><br><span class="line">    select(max+<span class="number">1</span>, &amp;rest, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// select函数会将所有的文件描述符中，有数据到来的那些描述符的对应位置置位1，其余位置置位0，</span></span><br><span class="line">    <span class="comment">//通过for循环判断哪些文件描述符被置位，从而读取其中的数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], &amp;rset))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">            read(fds[i],buffer,MAXBUF); <span class="comment">//读操作</span></span><br><span class="line">            <span class="built_in">puts</span>(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用内核态来判断那个套接字描述符有数据</p><p>缺点：有1024个文件描述符的限制；fd_set不可以重用，每次循环需要重新置位0；内核态复制文件描述符导致文件描述符列表越长需要复制的次数越多；O(n)遍历判断哪个位置的描述符被置位</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll函数格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd * fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>参数：指向pollfd结构体类型的指针，数组指针</p><p>​            关注的文件描述符的个数</p><p>​             时间</p><p>poolfd结构体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="type">short</span> revents;       <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125; ; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client,<span class="number">0</span>, <span class="keyword">sizeof</span>(client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    pollfds[i].fd = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);<span class="comment">//pollfds是pollfd类型的结构体数组</span></span><br><span class="line">    pollfds[i].events = POLLIN;<span class="comment">//关注的是有数据可读事件</span></span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>); <span class="comment">//调用poll函数，pollfds[i]发生了POLLIN事件，                                                  //把pollfds[i].revents对应于POLLIN置位为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pollfds[i].revents &amp; POLLIN)  <span class="comment">//可能有多个关注事件，要与对应的事件做与操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            pollfds[i].revents = <span class="number">0</span>;<span class="comment">//复位</span></span><br><span class="line">            <span class="comment">//处理数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><a href="https://zhuanlan.zhihu.com/p/406175793">epoll函数原理详解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event events[5];</span><br><span class="line">int c = epoll_create1(10);</span><br><span class="line">int epfd = epoll_create(10);//创建一个epoll对象，返回文件描述符,参数只要大于0即可</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">for(int i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">    static struct epoll_event ev;  //临时变量</span><br><span class="line">    memset(&amp;client, 0, sizeof(client));</span><br><span class="line">    addrlen = sizeof(client);</span><br><span class="line">    ev.data.fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen); //监听的套接字文件描述符</span><br><span class="line">    ev.events = EPOLLIN; //监听事件是读事件</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    nfds = epoll_wait(epfd, events, 5, 10000);</span><br><span class="line">    for(i=0;i&lt;ndfs;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //处理数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程-Linux系统编程3</title>
      <link href="/2023/12/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/"/>
      <url>/2023/12/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统编程3"><a href="#Linux系统编程3" class="headerlink" title="Linux系统编程3"></a>Linux系统编程3</h1><h2 id="dentry和inode"><a href="#dentry和inode" class="headerlink" title="dentry和inode"></a>dentry和inode</h2><p>参考：<a href="https://bean-li.github.io/vfs-inode-dentry/">https://bean-li.github.io/vfs-inode-dentry/</a></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312031438241.png" alt="image-20231203143825104"></p><p><strong>innode：</strong></p><p>本质是结构体，<strong>存储文件的属性信息</strong>。如权限、类型、大小、时间、用户、盘块位置等。大多数的inode都存储在磁盘上，少量常用</p><p><strong>dentry：</strong></p><p>目录项，本质是结构体，存有<strong>文件名</strong>和<strong>inode指针</strong>。因此一个文件可以有多个dentry项</p><h2 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h2><p>stat函数，用于获取文件属性，即<strong>获取的就是inode的内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int stat(const char *pathname, struct stat *statbuf);</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p>path：文件路径</p><p>buf：传出参数，存放<strong>文件属性</strong></p><p><strong>返回值</strong></p><p>成功：0，失败：-1</p><p><strong>stat结构体如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">   <span class="type">dev_t</span>     st_dev;         <span class="comment">/* 设备号码 */</span></span><br><span class="line">   <span class="type">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">   <span class="type">mode_t</span>    st_mode;        <span class="comment">/* 文件模式，文件、目录 */</span></span><br><span class="line">   <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">   <span class="type">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">   <span class="type">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">   <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">   <span class="type">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">   <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">   <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>判断文件类型</strong>，使用对应函数，传入stat结构体中的st_mode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = stat(argy[<span class="number">1</span>], &amp;sb);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">perror(<span class="string">&quot;stat eror&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(sb.st_mode)) <span class="comment">//常规文件</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a regular(n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s ISDIR(sb.st mode) <span class="comment">//目录</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a dirln&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(sb.st_mode)) <span class="comment">//管道</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a pipe n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(sb.st_mode)) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a sym link n&quot;</span>); <span class="comment">//链接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="link和unlink函数"><a href="#link和unlink函数" class="headerlink" title="link和unlink函数"></a>link和unlink函数</h2><p>Linux允许多个目录项共享一个inode，即共享盘块，从而使同一个文件有多个文件名。使用link函数，可以为已经存在的目录创建目录项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int link(const char *oldname, const char *newname);</span><br></pre></td></tr></table></figure><p>使用unlink可以删除一个文件的目录项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int unlink(const char* pathname);</span><br></pre></td></tr></table></figure><p>功能详解：unlink从文件系统中中删除一个dentry，若这个dentry是指向这个文件的最后一个链接，并且没有进程处于打开这个文件的状态，则删除这个文件，释放这个文件占用的空间。若这个dentry是指向这个文件的最后一个链接，但是有进程处于打开这个文件的状态，则暂时不删除文件，等到打开这个文件的进程关闭这个文件后，系统才择机删除这个文件。</p><h2 id="opendir、readdir函数"><a href="#opendir、readdir函数" class="headerlink" title="opendir、readdir函数"></a>opendir、readdir函数</h2><p>opendir打开一个目录文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*name)</span>;</span><br></pre></td></tr></table></figure><p>DIR表示目录流类型。</p><p>opendir()用来打开参数name 指定的目录, 并<strong>返回目录流指针</strong>,（相当于文件描述符fd）</p><p>对应的关闭时<code>closedir(DIR *name)</code></p><p>readdir函数返回参数dir 目录流的下个目录进入点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct dirent *readdir(DIR *dirp);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino; //d_ino 此目录项的inode</span><br><span class="line">    ff_t d_off; //d_off  目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen; //d_reclen _name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type; //d_type d_name 所指的文件类型 d_name 文件名</span><br><span class="line">    har d_name[256];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>返回值</strong>：成功则返回<strong>下个目录项指针</strong>。读取到目录文件尾则返回NULL,error不变，读取错误的话返回NULL，并且error被设置</p><p><strong>每次读一个项，就会有目录流读取位置就会往后偏移一项，使下次使用readdir可以读下一个目录项指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR * dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">    dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dp==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp))!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,sdp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rewinddir函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void rewinddir(DIR *dir)</span><br></pre></td></tr></table></figure><p>rewinddir()用来设置参数dir 目录流目前的读取位置为原来开头的读取位置.</p><p><strong>telldir函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_t telldir(DIR *dir);</span><br></pre></td></tr></table></figure><p>telldir()返回参数dir 目录流目前的读取位置。此返回值代表距离目录文件开头的偏移量，返回值返回下个读取位置。</p><p><strong>seekdir函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void seekdir(DIR * dir, off_t offset);</span><br></pre></td></tr></table></figure><p>seekdir()用来设置参数dir 目录流目前的读取位置, 在调用readdir()时便从此新位置开始读取. 参数offset 代表距离目录文件开头的偏移量。</p><h2 id="总结：实现ls功能"><a href="#总结：实现ls功能" class="headerlink" title="总结：实现ls功能"></a>总结：实现ls功能</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_file</span><span class="params">(<span class="type">char</span> *, <span class="type">const</span> <span class="type">int</span> )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">is_file</span><span class="params">(<span class="type">char</span> *,<span class="type">const</span> <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_file</span><span class="params">(<span class="type">char</span> *name, <span class="type">const</span> <span class="type">int</span> depth)</span> <span class="comment">//目录</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dp;<span class="comment">//目录流指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span> <span class="comment">//目录项指针</span></span><br><span class="line">    <span class="keyword">if</span>((dp = opendir(name)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>) <span class="comment">//对于目录中的文件，其打开路径都是：目录路径+文件名</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">char</span> file_true_path[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">char</span> lastChar =  name[<span class="built_in">strlen</span>(name)<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(lastChar==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            <span class="built_in">sprintf</span>(file_true_path,<span class="string">&quot;%s%s&quot;</span>,name,sdp-&gt;d_name);<span class="comment">//拼接</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">sprintf</span>(file_true_path,<span class="string">&quot;%s/%s&quot;</span>,name,sdp-&gt;d_name);<span class="comment">//拼接</span></span><br><span class="line">        is_file(file_true_path,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">is_file</span><span class="params">(<span class="type">char</span> *path, <span class="type">const</span> <span class="type">int</span> depth)</span> <span class="comment">//depth为文件层次</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(stat(path, &amp;sb)==<span class="number">-1</span>) <span class="comment">//读文件属性，判断是否出错</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(sb.st_mode))<span class="comment">//目录文件,打印目录</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*depth;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">//按深度打印空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,path);</span><br><span class="line">        Read_file(path,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*depth;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">//按深度打印空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %8ld\n&quot;</span>,path, sb.st_size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)</span><br><span class="line">        is_file(<span class="string">&quot;.&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    is_file(argv[<span class="number">1</span>],<span class="number">1</span>); <span class="comment">//目录根路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重定向（dup和dup2）"><a href="#重定向（dup和dup2）" class="headerlink" title="重定向（dup和dup2）"></a>重定向（dup和dup2）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;  <span class="comment">//oldfd是已有的文件描述符</span></span><br></pre></td></tr></table></figure><p>返回值：成功返回新的文件描述符</p><p>dup函数为oldfd指向的文件创建一个新的文件描述符副本，它们指向相同的打开文件描述符（参见 open(2)），因此共享文件偏移量和文件状态标志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(argv[1],O_RDWR|O_APPEND))==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int newfd = dup(fd);  //为一个相同文件返回新的文件描述符</span><br><span class="line">    printf(&quot;newfd = %d\n&quot;,newfd);</span><br><span class="line">    </span><br><span class="line">    if (write(newfd, &quot;1234567&quot;, 7) == -1) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;write error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd, int newfd);  //oldfd是已有的文件描述符,newfd是新的文件描述符</span><br></pre></td></tr></table></figure><p><code>dup2()</code> 系统调用执行与 <code>dup()</code> 类似的任务，但是不使用未使用的最低文件描述符号，而是使用在 <code>newfd</code> 中指定的文件描述符号。如果文件描述符 <code>newfd</code> 之前已经打开，则在被重用之前会被静默关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = open(argv[<span class="number">1</span>],O_RDWR|O_APPEND))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newfd = dup2(fd,STDOUT_FILENO); <span class="comment">//标准输出的文件描述符所指向得的文件，重定向到fd所指的文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------\n&quot;</span>); <span class="comment">//向标准输出写的数据会写入txt文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程-Linux系统编程2</title>
      <link href="/2023/12/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/"/>
      <url>/2023/12/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统编程2"><a href="#Linux系统编程2" class="headerlink" title="Linux系统编程2"></a>Linux系统编程2</h1><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将<strong>现有的存取权限减掉权限掩码后</strong>，即可产生建立文件时预设的权限。</p><p>linux创建文件文件默认权限为644，目录默认权限为755，默认权限掩码为022。</p><h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><p><strong>定义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br></pre></td></tr></table></figure><p>头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p><strong>1、pathname：</strong></p><p>相对该文件的绝对路径</p><p><strong>2、flags</strong>：</p><p>flags参数表示打开文件所采用的操作</p><ul><li>O_RDONLY：只读模式</li><li>O_WRONLY：只写模式</li><li>O_RDWR：可读可写</li></ul><p>以上三个参数是<strong>必须的</strong>，下边的选项是选用的，使用时需要与必选参数<code>|</code>起来，如<code>O_RDONLY|O_CREAT</code></p><ul><li><p>O_APPEND 表示追加，如果原来文件里面有内容，则这次写入会写在文件的最末尾。</p></li><li><p>O_CREAT 如果指定文件不存在，则创建这个文件  <code>fd = open(&quot;./2.txt&quot;,O_RDONLY|O_CREAT,0644);</code></p></li><li><p>O_EXCL 表示如果要创建的文件已存在，则出错，同时返回 -1，并且修改 errno 的值。</p></li><li><p>O_TRUNC 表示截断，如果文件存在，并且以<strong>只写、读写</strong>方式打开，则将其长度截断为0。</p></li><li><p>O_NOCTTY 如果路径名指向终端设备，不要把这个设备用作控制终端。</p></li><li><p>O_NONBLOCK 如果路径名指向 FIFO&#x2F;块文件&#x2F;字符文件，则把文件的打开和后继 I&#x2F;O设置为非阻塞模式（nonblocking mode）</p></li></ul><p><strong>3、mode:</strong></p><p>mode参数表示设置文件访问权限的初始值，和用户掩码umask有关,用于创建文件时使用，即第二个参数flags为<code>O_CREAT</code>时才有用</p><p><strong>返回值</strong></p><p>正常则返回一个整数，即文件描述符（int型），出现错误返回-1，并且<code>errno</code>被设置成对应的值</p><p><strong>常见错误：</strong></p><ul><li>打开文件不存在</li><li>以写方式打开只读文件</li><li>以只写或读写方式打开目录，只能用只读方式打开目录</li></ul><h2 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// 参数：文件描述符，缓冲区指针，缓冲区大小</span></span><br></pre></td></tr></table></figure><p>成功：返回读到的字节数</p><p>错误，返回-1，设置<code>errno</code>为对应值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write() 将从 buf 开始的缓冲区中写入 count 个字节到文件描述符 fd 引用的文件。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// count为要写入的字节数</span></span><br></pre></td></tr></table></figure><p>使用read和write实现cp操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> n;  <span class="comment">//每次读到的字节数</span></span><br><span class="line"><span class="type">int</span> fd_rd = open(<span class="string">&quot;./1.txt&quot;</span>,O_RDONLY);</span><br><span class="line"><span class="type">int</span> fd_wr = open(<span class="string">&quot;./2.txt&quot;</span>,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd_rd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open read_txt error&quot;</span>);<span class="comment">//输出错误提示，并输出strerror(errno)的系统错误信息</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fd_wr == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open write_txt error&quot;</span>); </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先把数据读入缓冲区</span></span><br><span class="line"><span class="keyword">while</span>( (n = read(fd_rd,&amp;buf,<span class="keyword">sizeof</span>(buf))) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">write(fd_wr, buf, n); <span class="comment">//这里是n</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">close(fd_rd);</span><br><span class="line">close(fd_wr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312012042842.png" alt="image-20231201204236724"></p><p>PCB进程控制块，本质是结构体。其中有个指针变量，指向文件描述符表。</p><p>文件描述符表是一个数组，其中的下标0、1、2、….1023就是文件描述符，而数组中存的是每个文件的每个文件结构体file的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">文件的偏移量</span><br><span class="line">文件的访问权限</span><br><span class="line">文件的打开标志</span><br><span class="line">    文件在内核缓冲区的首地址</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><p>0-STDIN_FILENO</p><p>1-STDOUT_FILENO</p><p>2-STDERR_FILENO</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>读常规文件是不会阻塞的，不管读多少字节，read 一定会在有限的时间内返回。从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用 read 读终端设备就会阻塞，如果网络上没有接收到数据包，调用 read 从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。<br>产生阻塞的场景。设备文件、读网络文件</p><p>&#x2F;dev&#x2F;tty —–终端文件 <code>open(&quot;/dev/tty,O_RDWR|O_NONBLOCK&quot;)</code></p><h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>获取文件状态：F_GETFL <code>int flags = fctl(0,F_GETFL)</code></p><p>设置文件状态：F_SETFL  <code>fcntl(STDIN_FILENO,F_SETFL,flags)</code></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312021229678.png" alt="image-20231202122934603"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> flags,n;</span><br><span class="line"><span class="keyword">if</span>((flags = fcntl(STDIN_FILENO,F_GETFL))==<span class="number">-1</span>) <span class="comment">//获取stdin属性信息</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flags |= O_NONBLOCK;  <span class="comment">//增加O_NONBLOCK位信息</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="keyword">if</span>((ret = fcntl(STDIN_FILENO,F_SETFL,flags))==<span class="number">-1</span>)  <span class="comment">//设置标准输入文件为非阻塞状态</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fcntl set error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tryagain:</span><br><span class="line">n = read(STDIN_FILENO,buf,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="comment">//当以非阻塞状态读文件时，如果缓冲区中没有数据，则返回-1，同时设置errno为EGAIN，因此这样判断</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno != EAGAIN)&#123;</span><br><span class="line">perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line">write(STDOUT_FILENO, <span class="string">&quot;try again\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;try again\n&quot;</span>)); <span class="comment">//向标准输出中写入try again，表示一次尝试</span></span><br><span class="line"><span class="keyword">goto</span> tryagain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果从缓冲区中读到数据，就写入标准输出文件中</span></span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h2><p>Linux系统中使用系统函数来修改文件偏移量（读写位置）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>参数<code>whence</code></p><blockquote><p>SEEK_SET:  　　从文件头部开始偏移offset个字节。  </p><p>SEEK_CUR：  　从文件当前读写的指针位置开始，增加offset个字节的偏移量。  </p><p>SEEK_END：  　文件偏移量设置为文件的大小加上偏移量字节。</p></blockquote><p>返回值</p><blockquote><p>成功：返回值是较文件起始位置向后的偏移量</p><p>失败：返回-1</p></blockquote><p>注意：打开文件后，文件的读和写使用同一个偏移位置</p><p>应用场景：</p><ul><li><p>文件打开后，文件的读和写使用同一个偏移位置</p></li><li><p>使用lseek获取文件大小</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);  <span class="comment">//获取文件大小，单位：字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;length=%d\n&quot;</span>,len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用lseek拓展文件大小；要想使文件大小真正改变，必须使用IO操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = lseek(fd, <span class="number">100</span>, SEEK_END); <span class="comment">//len增加100,此时ls -l Read.txt其大小没变</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;length=%d\n&quot;</span>,len);</span><br><span class="line">write(fd,<span class="string">&quot;\0&quot;</span>,<span class="number">1</span>);   <span class="comment">// 调用IO操作，写入磁盘。此时才发生变化</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>act -A Read.txt</code>查看文件，包括特殊字符</p><p>也可以使用<code>truncate</code>函数直接拓展，<code>truncate(char *path,  off_t length)</code></p><blockquote><p>如果文件以前大于此大小，则多余的数据将丢失。 如果之前的文件较短，则会扩展它，扩展部分读取为空字节（’\0’）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程-Linux系统编程1</title>
      <link href="/2023/11/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"/>
      <url>/2023/11/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统编程1"><a href="#Linux系统编程1" class="headerlink" title="Linux系统编程1"></a>Linux系统编程1</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><code>ctrl+a</code>:光标移到命令行最前面</p><p><code>ctrl+e</code>:光标移到命令行最后面</p><p><code>ctrl+u</code>:删除整行</p><h2 id="gcc编译的四个阶段"><a href="#gcc编译的四个阶段" class="headerlink" title="gcc编译的四个阶段"></a>gcc编译的四个阶段</h2><ul><li><p>预处理：<code>gcc -E helloworld.c -o helloworld.i</code></p></li><li><p>编译：<code>gcc -S helloworld.i -o helloworld.s</code>           <strong>编译阶段出错，会给出行号</strong></p></li><li><p>汇编：<code>gcc -c helloworld.s -o helloworld.o</code></p></li><li><p>链接：<code>gcc helloworld.o -o helloworld</code>                    <strong>链接阶段出错，会有<code>collect: error: ld</code></strong></p></li></ul><h2 id="gcc编译常用命令"><a href="#gcc编译常用命令" class="headerlink" title="gcc编译常用命令"></a>gcc编译常用命令</h2><ul><li><code>-o</code>：指定生成的文件</li><li><code>-I </code>：指定头文件的路径</li><li><code>-g</code>：编译时添加调试语句（要使用gdb调试时必须加这个参数）</li><li><code>-Wall</code>：显示所有警告信息</li><li><code>-D</code>：向当前程序中注册一个宏，如<code>gcc hello.c -D HELLO</code>就是注册了一个HELLO的宏用作开关来输出调试信息</li></ul><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><p>静态库会在链接的时候直接把库文件复制到程序中，运行的时候不再依赖库文件。以<code>.a</code>为后缀</p><p>动态库是在运行时动态加载。以<code>.so</code>为后缀</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello 编程珠玑\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> a = <span class="built_in">exp</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于这个函数，使用了math.h中的exp函数</p><p>静态链接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="type">static</span> main.c -o main -lm</span><br></pre></td></tr></table></figure><p>动态链接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -lm</span><br></pre></td></tr></table></figure><p>使用了<code>-l</code>参数，后边的<code>m</code>是<code>math.h</code>的基本名称</p><p>可以使用<code>ldd main</code>查看动态链接文件的都链接了哪些库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wufang@wufang:~/C++_base_learning$ ldd test1</span><br><span class="line">linux-vdso.so.1 (0x00007ffca1fc5000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f2cb480f000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2cb4400000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f2cb490b000)</span><br></pre></td></tr></table></figure><p>如何判断一个函数是否需要链接呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="number">3</span> 函数名</span><br></pre></td></tr></table></figure><h2 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h2><ol><li>将.c文件编译生成.o文件  <code>gcc -c add.c -o add</code></li><li>使用ar工具制作静态库 <code>ar rcs lib库名.a add.o sub.o</code></li><li>编译静态库到可执行文件中<code>gcc main.c lib库名.a -o main </code></li></ol><p>按这样三部编译出可执行文件后，会出现如下警告</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.c:<span class="number">8</span>:<span class="number">33</span>: warning: implicit declaration of function ‘add’ [-Wimplicit-function-declaration]</span><br><span class="line">    <span class="number">8</span> |         <span class="built_in">printf</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>,a,b,add(a,b));</span><br><span class="line">      |                                 ^~~</span><br><span class="line">test.c:<span class="number">9</span>:<span class="number">33</span>: warning: implicit declaration of function ‘sub’ [-Wimplicit-function-declaration]</span><br><span class="line">    <span class="number">9</span> |         <span class="built_in">printf</span>(<span class="string">&quot;%d-%d=%d\n&quot;</span>,a,b,sub(a,b));</span><br><span class="line">      |                                 ^~~</span><br><span class="line">wufang@wufang:~/C++_base_learning$ ./test</span><br></pre></td></tr></table></figure><p>这个警告告诉：<strong>对add的隐式声明</strong>，因此，我们需要额外对使用的库函数进行声明，写在一个<code>库名.h</code>文件中，文件格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYMATH_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MMYMATH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这使用了头文件首位，目的是：防止重复引入和重复定义。<a href="https://www.cnblogs.com/flowingwind/p/8304668.html">https://www.cnblogs.com/flowingwind/p/8304668.html</a></p><p>制作好.h文件后，在.cpp文件中引入.h头文件（<code>#include &quot;mymath.h&quot;</code>）。此时的编译命令为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c ./lib/lib库名.a -o main.out -I ./inc</span><br></pre></td></tr></table></figure><p>静态库文件放在lib中，头文件放在inc中</p><h2 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h2><p>参考：<a href="https://cloud.tencent.com/developer/article/1711778">https://cloud.tencent.com/developer/article/1711778</a></p><ol><li><p>将.c文件编译生成与位置无关的二进制文件：<code>gcc -c add.c -o add.o -fPIC </code></p></li><li><p>使用<code>gcc -shared</code>制作动态库：<code>gcc -shared -o lib库名.so add.o sub.o div.o</code></p></li><li><p>编译可执行程序，指定所使用的动态库。 <code>-l</code>指定库名，<code>-L</code>指定动态库路径, <code>-I</code>指定库的头文件路径</p><p><code>gcc test.c -o test.out -l库名 -L./lib -I ./inc</code></p></li></ol><p><strong>注意：-l后边紧跟库名，-L后紧跟库路径，空格可有可无</strong></p><p>按上边步骤完成后，运行可执行文件，报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wufang@wufang:~/C++_base_learning/dynamic$ gcc test.c -o test.out -lmymath -L./lib -I./inc</span><br><span class="line">wufang@wufang:~/C++_base_learning/dynamic$ ./test.out </span><br><span class="line">./test.out: error <span class="keyword">while</span> loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>这个报错是因为<strong>动态链接器</strong>在运行程序的时候找不到需要链接的库。解决办法有三种，如下给出视频中的方法：</p><p>即 将动态库的路径写入<strong>用户终端配置文件</strong><code>.bashrc</code>中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bachrc  <span class="comment">#打开用户自己的终端配置文件</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=....  <span class="comment">#添加链接路径，最好使用绝对路径</span></span><br><span class="line"><span class="built_in">source</span> .bashrc   <span class="comment">#运行生效</span></span><br></pre></td></tr></table></figure><p>解决方法合集：<a href="https://www.jianshu.com/p/a3b2b6f5f0fc">https://www.jianshu.com/p/a3b2b6f5f0fc</a></p><h2 id="gdb调试工具"><a href="#gdb调试工具" class="headerlink" title="gdb调试工具"></a>gdb调试工具</h2><p>基础指令：</p><ul><li><code>-g</code>：使用该参数编译可执行文件，得到调试表</li><li><code>gdb ./a.out</code>：</li><li><code>set listsize 行数</code>：设置list打印行数</li><li><code>list 1</code>：从第一行开始打印</li><li><code>b/break</code>：设置断点，后边可以跟着行号或者函数名</li><li><code>run</code>：直接运行程序，如果设置断点了，会运行到断点，如果程序出错了，会直接运行到出错位置</li><li><code>s/step</code>：下一条指令（会进入函数）</li><li><code>n/next</code>：下一条指令（越过函数）</li><li><code>finish</code>：进入函数后，结束当前函数调用，即退出该函数</li><li><code>p/print</code>：p i 查看变量i的值</li><li><code>c/continue</code>：运行程序到下一个断点或者结束</li><li><code>quit</code>：退出gdb</li></ul><p>其它指令：</p><ul><li><p><code>start</code>：从main函数的第一行开始</p></li><li><p><code>set args</code>：设置main函数命令行参数</p></li><li><p><code>info b</code>：查看所有断点信息</p></li><li><p><code>b 20 if i = 5</code>设置条件断点，用在循环语句，嵌套递归中</p></li><li><p><code>bt</code>：查看程序中正在存活的栈帧</p></li><li><p><code>fram 栈帧编号</code>：切换栈帧</p></li><li><p><code>display 变量</code>：跟踪变量</p></li><li><p><code>undisplay 变量编号</code>：取消跟踪</p></li></ul><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h3><p>test.c中是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将函数声明写在了main函数中，后续会给出将函数声明写在.h中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">14</span>, b = <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>,a,b,add(a,b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-%d=%d\n&quot;</span>,a,b,sub(a,b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1个规则：</strong></p><p>目标：依赖条件</p><p>​（一个Tab缩进）命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o add.o sub.o</span></span><br><span class="line">        gcc test.o add.o sub.o -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c test.c -o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">        gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">        gcc -c sub.c -o sub.o</span><br></pre></td></tr></table></figure><p>基本原则：</p><ol><li>若想生成目标文件，检查规则中的依赖条件是否存在，如不存在，则寻找是否有规则用来生成该依赖文件</li><li>检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任何一项被更新，则目标更新</li></ol><p><strong>2个函数：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>   <span class="comment">#找到当前目录下所有后缀未.c的文件，赋值给src</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o <span class="variable">$(src)</span>)</span>  <span class="comment">#将src变量中包含.c后缀的文件都替换成.o后缀</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:@(obj)</span></span><br><span class="line">        gcc @(obj) -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c test.c -o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">        gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">        gcc -c sub.c -o sub.o</span><br><span class="line">        </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> test   <span class="comment">#将生成的.o文件和可执行文件都删了，rm前的&quot;-&quot;表示出错依然执行</span></span><br></pre></td></tr></table></figure><p><strong>3个变量：</strong></p><blockquote><p>$@：在一条规则的<strong>命令</strong>中，表示该规则的目标</p><p>$^：在一条规则的命令中使用，用于表示这条规则的所有依赖条件</p><p>$&lt;：在一条规则的命令中使用，用于表示这条规则的依赖条件列表中的第一个依赖条件</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>  </span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(obj)</span></span></span><br><span class="line">gcc <span class="variable">$^</span>  -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o sub.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> test</span><br></pre></td></tr></table></figure><p><strong>模式规则：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o test.o</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o add.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o sub.o</span><br><span class="line"><span class="comment"># 可以将上面的结构重复的代码做如下替换</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>最终的makefile代码可以这样写</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>  </span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">CXX = gcc  <span class="comment">#编译器，可以根据需要改成g++</span></span><br><span class="line">myArgs = -Wall -g <span class="comment">#调试选项，使得编译的文件可以进行调试</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(obj)</span></span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean  #伪目标，因为文件夹中可能存在同名的clean文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> test</span><br></pre></td></tr></table></figure><h3 id="重构版"><a href="#重构版" class="headerlink" title="重构版"></a>重构版</h3><p>项目文件夹下有如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc       makefile  obj       src</span><br></pre></td></tr></table></figure><p>其中，<code>inc</code>文件夹存放<code>头文件</code>，<code>src</code>文件夹存放<code>.c或者.cpp源代码</code>，<code>obj</code>文件夹存放<code>.o目标文件</code></p><p><code>makefile</code>文件如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./src/*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> ./src/%.c, ./obj/%.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">inc_path = ./inc  <span class="comment">#头文件所在位置</span></span><br><span class="line">myArgs = -Wall -g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(obj)</span></span></span><br><span class="line">        gcc <span class="variable">$^</span> -o test <span class="variable">$(myArgs)</span></span><br><span class="line">        </span><br><span class="line"><span class="variable">$(obj)</span>:./obj%.o:./src%.c</span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span> -I <span class="variable">$(inc_path)</span>  <span class="comment">#在编译生成目标文件时需要指出头文件位置</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        -rm -rf <span class="variable">$(obj)</span> test</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vscode调试Linux内核</title>
      <link href="/2023/11/20/Vscode%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8/"/>
      <url>/2023/11/20/Vscode%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Vscode调试Linux内核"><a href="#使用Vscode调试Linux内核" class="headerlink" title="使用Vscode调试Linux内核"></a>使用Vscode调试Linux内核</h1><p>上一篇博客我们在虚拟机中编译了Linux内核，并且使用Qemu和gdb进行调试，但是gdb的指令我还不熟练，还是想用vscode来调试，这样也更加方便</p><h2 id="Vscode插件安装"><a href="#Vscode插件安装" class="headerlink" title="Vscode插件安装"></a>Vscode插件安装</h2><h3 id="remote-ssh"><a href="#remote-ssh" class="headerlink" title="remote-ssh"></a>remote-ssh</h3><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201245007.png" alt="image-20231120124509960"></p><p>安装完成后右边工具栏会多出一个功能</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201246229.png" alt="image-20231120124653194"></p><p>按F1呼出对话框，输入<code>remote-ssh</code>，选择open ssh configuration file。</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201247886.png" alt="image-20231120124748850"></p><p>选择第一个配置文件</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201248231.png" alt="image-20231120124824202"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host 自定义连接名称</span><br><span class="line">    HostName 服务器IP地址</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><h3 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h3><p>安装C&#x2F;C++插件</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201251048.png" alt="image-20231120125110014"></p><p>依次点击【运行】-&gt;【打开配置】，将以下配置复制到launch.json中。</p><p><strong>该代码不需要更改，直接粘贴</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kernel-debug&quot;</span><span class="punctuation">,</span>   <span class="comment">//随便起名</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:1234&quot;</span><span class="punctuation">,</span>  <span class="comment">//远端调试地址，1234为qemu的监视端口</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/vmlinux&quot;</span><span class="punctuation">,</span>     <span class="comment">//当前目录下的vmlinux</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;engineLogging&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Vscode调试"><a href="#Vscode调试" class="headerlink" title="Vscode调试"></a>Vscode调试</h2><h3 id="在虚拟机中启动qemu"><a href="#在虚拟机中启动qemu" class="headerlink" title="在虚拟机中启动qemu"></a>在虚拟机中启动qemu</h3><p>在<strong>Linux内核文件夹下</strong>运行此命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./arch/x86/boot/bzImage -initrd ../initramfs.cpio.gz -append <span class="string">&quot;nokaslr console=ttyS0&quot;</span> -s -S -nographic</span><br></pre></td></tr></table></figure><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p>打开init&#x2F;main.c，我打了如下的断点</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201300424.png" alt="image-20231120130037370"></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201305050.png" alt="image-20231120130522009"></p><p>然后在vscode中就可以看到调试结果了</p><h2 id="代码中标红的问题"><a href="#代码中标红的问题" class="headerlink" title="代码中标红的问题"></a>代码中标红的问题</h2><p>代码标红是缺少compile_commands.json文件</p><p>我在B站上学习的时候，是跟着这位up主来的（源码被猫吃了），他的解决方案如下：</p><p>在终端键入命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/clang-tools/gen_compile_commands.py</span><br></pre></td></tr></table></figure><p>在源码目录下就生成了<code>compile_commands.json</code>文件</p><p>在vscode中：<code>ctrl+shipt+p</code>选择C&#x2F;C++：Edit Coonfigurations,</p><p>在c_cpp_properties.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compileCommands&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/compile_commands.json&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此后，main.c中的代码就不标红了</p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用虚拟机进行基于qemu和gdb的Linux内核调试</title>
      <link href="/2023/11/20/%E9%85%8D%E7%BD%AELinux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
      <url>/2023/11/20/%E9%85%8D%E7%BD%AELinux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="使用虚拟机进行基于qemu和gdb的Linux内核调试"><a href="#使用虚拟机进行基于qemu和gdb的Linux内核调试" class="headerlink" title="使用虚拟机进行基于qemu和gdb的Linux内核调试"></a>使用虚拟机进行基于qemu和gdb的Linux内核调试</h1><h2 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><p>至少分8个核心（不然编译速度很慢，亲测）</p><p>磁盘大小分50G（编译后的内核大小有20多个G！）</p><h2 id="打开SSH"><a href="#打开SSH" class="headerlink" title="打开SSH"></a>打开SSH</h2><p>虚拟机中安装的是ubuntu22.04版本，默认没有安装和启用SSH服务</p><p><strong>更新软件源</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure><p><strong>安装SSH(OpenSSH)</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server -y</span><br></pre></td></tr></table></figure><p><strong>启动SSH服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now ssh</span><br></pre></td></tr></table></figure><p><strong>检查是否启动成功</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status ssh</span><br></pre></td></tr></table></figure><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装相关依赖</span></span><br><span class="line">sudo apt-get install libncurses5-dev libssl-dev bison flex libelf-dev gcc g++ make openssl libc6-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装gdb，这里使用apt安装（多次尝试的结果）</span></span><br><span class="line">sudo apt-get install gdb</span><br><span class="line">gdb --version <span class="comment"># gdb版本为12.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里选择清华源，国内速度会快很多</span></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.14.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xvf linux-5.14.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置编译选项</span></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>然后会在此文件夹下生成 <strong>.&#x2F;config</strong>文件</p><p><strong>进入该文件，并做以下2处修改</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./.config</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201128412.png" alt="image-20231117212013850"></p><p><strong>安装dwarves软件包（编译报错得出结论）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dwarves</span><br></pre></td></tr></table></figure><p><strong>BTF报错解决</strong></p><p>如果仅仅只进行了上边的配置，会报如下错误（我个人是这样）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  KSYMS   .tmp_vmlinux.kallsyms1.S</span><br><span class="line">  AS      .tmp_vmlinux.kallsyms1.S</span><br><span class="line">  LD      .tmp_vmlinux.kallsyms2</span><br><span class="line">  KSYMS   .tmp_vmlinux.kallsyms2.S</span><br><span class="line">  AS      .tmp_vmlinux.kallsyms2.S</span><br><span class="line">  LD      vmlinux</span><br><span class="line">  BTFIDS  vmlinux</span><br><span class="line">FAILED: load BTF from vmlinux: Invalid argument</span><br><span class="line">make: *** [Makefile:1187: vmlinux] Error 255</span><br><span class="line">make: *** Deleting file <span class="string">&#x27;vmlinux&#x27;</span></span><br></pre></td></tr></table></figure><p>查阅资料后，有三种解决方案：<a href="https://devkernel.io/posts/pahole-error/">https://devkernel.io/posts/pahole-error/</a></p><p>我使用的是<strong>第二种方法</strong>，对pahole软件包进行降级 :</p><p>查看pahole的版本，是1.25</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pahole --version  </span><br></pre></td></tr></table></figure><p>查看pahole的所有可用安装版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache policy pahole</span><br></pre></td></tr></table></figure><p>截图如下</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201127209.png" alt="1"></p><p>我们发现只有两个版本，因此只能降级为 1.22-8</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pahole=1.22-8</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8      <span class="comment">#8个线程并行编译，</span></span><br></pre></td></tr></table></figure><p>然后可能会弹出一个选择（1，2，3），直接选择1即可。等待一段时间，30分钟左右</p><h3 id="是否成功"><a href="#是否成功" class="headerlink" title="是否成功"></a>是否成功</h3><p>编译完成后，目录下会生成以下,那么就编译成功了</p><blockquote><p>.&#x2F;vmLinux</p><p>.&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage</p><p>其中vmLinux为GDB所需的调试Map文件，bzImage为大内核文件</p></blockquote><h2 id="安装Qemu"><a href="#安装Qemu" class="headerlink" title="安装Qemu"></a>安装Qemu</h2><p>qemu是一款完全软件模拟(Binary translation)的虚拟化软件，在虚拟化的实现中性能相对较差。但利用它在测试环境中gdb调试Linux内核代码，是熟悉Linux内核代码的一个好方法。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装qemu</span></span><br><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure><h2 id="安装编译busybox"><a href="#安装编译busybox" class="headerlink" title="安装编译busybox"></a>安装编译busybox</h2><p>安装busybox的目的是：借助BusyBox构建极简initramfs，提供基本的用户态可执行程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2  <span class="comment"># 去官网找最新版</span></span><br><span class="line">tar -xvf busybox-1.36.1.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.36.1/</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>在编译busybox之前，我们需要对其进行设置，执行<code>make menuconfig</code>，如下</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201135953.png" alt="image-20231120113536905"></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201136740.png" alt="image-20231120113608696"></p><p>这里一定要选择<strong>静态编译</strong>，编译好的可执行文件<code>busybox</code>不依赖动态链接库，可以独立运行，方便构建initramfs。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j 8</span><br><span class="line">make &amp;&amp; make install <span class="comment"># 安装完成后生成的相关文件会在 _install 目录下</span></span><br></pre></td></tr></table></figure><h2 id="构建initramfs根文件系统"><a href="#构建initramfs根文件系统" class="headerlink" title="构建initramfs根文件系统"></a>构建initramfs根文件系统</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在busybox压缩包的下载目录下,创建的该文件夹，该文件夹下有</span></span><br><span class="line"><span class="comment"># wufang@wufang:~/linux_kernel/kernel_compile$ ls</span></span><br><span class="line"><span class="comment"># busybox-1.36.1   busybox-1.36.1.tar.bz2   linux-5.14  linux-5.14.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> initramfs</span><br><span class="line"><span class="built_in">cd</span> initramfs</span><br><span class="line"><span class="built_in">cp</span> ../busybox-1.29.0/_install/* -rf ./ <span class="comment">#将_install文件夹下的所有文件复制到initramfs文件夹下</span></span><br><span class="line"><span class="built_in">mkdir</span> dev proc sys</span><br><span class="line">sudo <span class="built_in">cp</span> -a /dev/&#123;null,console,<span class="built_in">tty</span>,tty1,tty2,tty3,tty4&#125; dev/</span><br><span class="line"><span class="built_in">rm</span> -f linuxrc</span><br><span class="line">vim init</span><br></pre></td></tr></table></figure><p>添加如下代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/busybox sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#123;==DBG==&#125; INIT SCRIPT&quot;</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;&#123;==DBG==&#125; Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line"><span class="built_in">exec</span> /sbin/init</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x init 修改文件权限</span><br><span class="line"><span class="comment"># 完成后，initrams下有如下文件</span></span><br><span class="line"><span class="comment"># bin   dev   init  proc  sbin  sys   usr</span></span><br></pre></td></tr></table></figure><p><strong>打包initramfs</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.cpio.gz</span><br><span class="line"><span class="comment"># 此时在busybox压缩包的下载目录下，有如下文件</span></span><br><span class="line"><span class="comment"># busybox-1.36.1          initramfs               linux-5.14</span></span><br><span class="line"><span class="comment"># busybox-1.36.1.tar.bz2  initramfs.cpio.gz       linux-5.14.tar.gz</span></span><br></pre></td></tr></table></figure><h2 id="启动Qemu调试内核"><a href="#启动Qemu调试内核" class="headerlink" title="启动Qemu调试内核"></a>启动Qemu调试内核</h2><p>上述完成之后，就可以启动Qemu来调试内核了,启动代码如下（是一个指令）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./arch/x86/boot/bzImage -initrd ../initramfs.cpio.gz -append <span class="string">&quot;nokaslr console=ttyS0&quot;</span> -s -S -nographic</span><br></pre></td></tr></table></figure><ul><li><code>qemu-system-x86_64</code>：指定是x86，64位;</li><li><code>-kernel ./arch/x86/boot/bzImage</code>：指定启用的内核镜像；</li><li><code>-initrd ../initramfs.cpio.gz</code>：指定启动的内存文件系统</li><li><code>-append &quot;nokaslr console=ttyS0&quot;</code> ：附加参数，其中 <code>nokaslr</code> 参数<strong>必须添加进来</strong>，防止内核起始地址随机化，这样会导致 gdb 断点不能命中；</li><li><code>-s</code> ：监听在 gdb 1234 端口；</li><li><code>-S</code> ：表示启动后就挂起，等待 gdb 连接；</li><li><code>-nographic</code>：不启动图形界面</li></ul><p>开启另一个命令行窗口，输入<strong>gdb</strong>，即可开启调试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote localhost:1234  <span class="comment">#连接qemu监听的端口</span></span><br><span class="line">(gdb) <span class="built_in">break</span> start_kernel      <span class="comment">#在start_kernel打断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span>  rest_init        <span class="comment">#在res_init打断点</span></span><br><span class="line">(gdb) c                       <span class="comment">#运行到断点处</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly中取消头像转动</title>
      <link href="/2023/11/18/hexo1/"/>
      <url>/2023/11/18/hexo1/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-Butterfly中鼠标放到头像上头像会转动，如何取消转动"><a href="#Hexo-Butterfly中鼠标放到头像上头像会转动，如何取消转动" class="headerlink" title="Hexo+Butterfly中鼠标放到头像上头像会转动，如何取消转动"></a>Hexo+Butterfly中鼠标放到头像上头像会转动，如何取消转动</h2><p>这个在_config中改不了，经过查阅资料，发现在 hexo-theme-butterfly&#x2F;source&#x2F;css&#x2F;_layout&#x2F;aside.styl中进行更改,大约在324行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img</span><br><span class="line">  width: 100%</span><br><span class="line">  height: 100%</span><br><span class="line">  transition: filter 375ms ease-in .2s, transform .3s</span><br><span class="line">  object-fit: cover</span><br><span class="line"></span><br><span class="line">  &amp;:hover</span><br><span class="line">    transform: rotate(360deg)</span><br></pre></td></tr></table></figure><p>将后两行删掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img</span><br><span class="line">  width: 100%</span><br><span class="line">  height: 100%</span><br><span class="line">  transition: filter 375ms ease-in .2s, transform .3s</span><br><span class="line">  object-fit: cover</span><br></pre></td></tr></table></figure><p>这样头像就不会转动了</p><p>参考链接: <a href="https://github.com/jerryc127/hexo-theme-butterfly/discussions/878">https://github.com/jerryc127/hexo-theme-butterfly/discussions/878</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 更改配置 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
