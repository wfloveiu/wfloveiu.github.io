<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux虚拟内存管理(源码阅读1)</title>
      <link href="/2023/12/25/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1)/"/>
      <url>/2023/12/25/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1)/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用虚拟内存"><a href="#为什么使用虚拟内存" class="headerlink" title="为什么使用虚拟内存"></a>为什么使用虚拟内存</h2><p>一句话：引入虚拟内存后，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的。</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251453156.png" alt="640"></p><h2 id="虚拟内存地址格式"><a href="#虚拟内存地址格式" class="headerlink" title="虚拟内存地址格式"></a>虚拟内存地址格式</h2><p>都以4K为基本页框大小</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251455900.png" alt="image-20231225145536867"></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251455383.png" alt="image-20231225145517347"></p><h2 id="进程的虚拟内存空间"><a href="#进程的虚拟内存空间" class="headerlink" title="进程的虚拟内存空间"></a>进程的虚拟内存空间</h2><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251458277.png" alt="640 (1)"></p><ul><li>用于存放进程程序二进制文件中的机器指令的代码段</li><li>用于存放程序二进制文件中定义的全局变量和静态变量的数据段和 BSS 段。其中数据段中为指定了初始值的全局变量和静态变量；BSS段中为为指定初始值的全局变量和静态变量（初始化为0）</li><li>用于在程序运行过程中动态申请内存的堆。堆空间中地址的增长方向是从低地址到高地址增长。</li><li>用于存放动态链接库以及内存映射区域的文件映射与匿名映射区。</li><li>用于存放函数调用过程中的局部变量和函数参数的栈。</li></ul><h3 id="虚拟内存空间分布"><a href="#虚拟内存空间分布" class="headerlink" title="虚拟内存空间分布"></a>虚拟内存空间分布</h3><p>虚拟内存空间包括用户态和内核态。</p><h4 id="32位机器"><a href="#32位机器" class="headerlink" title="32位机器"></a>32位机器</h4><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251503730.png" alt="640 (2)"></p><p>用户态虚拟内存空间中的代码段并不是从 0x0000 0000 地址开始的，而是从 0x0804 8000 地址开始。</p><p>0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段不可访问的保留区，因为在大多数操作系统中，数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的。比如在 C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。</p><p>BSS 段的上边就是我们经常使用到的堆空间，从图中的红色箭头我们可以知道在<strong>堆空间中地址的增长方向是从低地址到高地址增长</strong>。</p><p>内核中使用 start_brk 标识堆的起始位置，brk 标识堆当前的结束位置。当堆申请新的内存空间时，只需要将 brk 指针增加对应的大小，回收地址时减少对应的大小即可。比如当我们通过 malloc 向内核申请很小的一块内存时（128K 之内），就是通过改变 brk 位置实现的。</p><p>堆空间的上边是一段待分配区域，用于扩展堆空间的使用。</p><p>接下来就来到了文件映射与匿名映射区域。<strong>在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长</strong>。</p><p>接下来用户态虚拟内存空间的最后一块区域就是栈空间了，在这里会保存函数运行过程所需要的局部变量以及函数参数等函数调用信息。<strong>栈空间中的地址增长方向是从高地址向低地址增长</strong>。</p><p>在内核中使用 start_stack 标识栈的起始位置，RSP 寄存器中保存栈顶指针 stack pointer，RBP 寄存器中保存的是栈基地址。在栈空间的下边也有一段待分配区域用于扩展栈空间。</p><h4 id="64位机器"><a href="#64位机器" class="headerlink" title="64位机器"></a>64位机器</h4><p>虽然64位机器的指针寻址范围是2^64,但是在目前的 64 位系统下只使用了 <strong>48 位来描述虚拟内存空间</strong>，寻址范围为  2^48 ，所能表达的虚拟内存空间为 256TB。</p><p>其中低 128 T 表示用户态虚拟内存空间，虚拟内存地址范围为：0x0000 0000 0000 0000  - 0x0000 7FFF FFFF F000 。</p><p>高 128 T 表示内核态虚拟内存空间，虚拟内存地址范围为：0xFFFF 8000 0000 0000  - 0xFFFF FFFF FFFF FFFF 。</p><p>这样一来就在用户态虚拟内存空间与内核态虚拟内存空间之间形成了一段 0x0000 7FFF FFFF F000  -  0xFFFF 8000 0000 0000  的地址空洞，我们把这个空洞叫做 canonical address 空洞</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251733199.png" alt="640 (4)"></p><p>如上图，还可以看到：在代码段跟数据段的中间还有一段不可以读写的保护段，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。</p><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间全部是一样的。</p><p>直接看参考文献第7节吧：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21#wechat_redirect">参考文献</a></p><h2 id="进程虚拟内存空间的管理"><a href="#进程虚拟内存空间的管理" class="headerlink" title="进程虚拟内存空间的管理"></a>进程虚拟内存空间的管理</h2><p>内核中的进程描述符<code>task_struct</code>结构</p><p>在  <code>include/linux/sched.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"> <span class="comment">// 进程id</span></span><br><span class="line">     <span class="type">pid_t</span>    pid;</span><br><span class="line">      <span class="comment">// 进程打开的文件信息</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>  *<span class="title">files</span>;</span></span><br><span class="line">     <span class="comment">// 该进程的虚拟地址空间结构体指针</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>*<span class="title">mm</span>;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在<code>include/linux/mm_types.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> task_size;  <span class="comment">// 用户态和内核态的分界线</span></span><br><span class="line">    <span class="comment">// 使用如下属性定义虚拟内存中的不同区域</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;  <span class="comment">/* base of mmap area */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm;    <span class="comment">/* Total pages mapped */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_vm;  <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pinned_vm;  <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data_vm;    <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> exec_vm;    <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm;    <span class="comment">/* VM_STACK */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>task_size定义了用户态地址空间与内核态地址空间之间的分界线。32 位系统中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。32 位系统中task_size 为 0xC000 000。同理，64 位系统中用户地址空间和内核地址空间的分界线在  0x0000 7FFF FFFF F000 地址处，那么自然进程的 mm_struct 结构中的 task_size 为 0x0000 7FFF FFFF F000 。</p><p>start_code 和 end_code 定义代码段的起始和结束位置，start_data 和 end_data 定义数据段的起始和结束位置；start_brk 定义堆的起始位置，brk 定义堆当前的结束位置，start_stack 是栈的起始位置在RBP寄存器中，栈的结束位置也就是栈顶指针 stack pointer 在 RSP 寄存器中存储；arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。它们都位于栈中的最高地址处；mmap_base 定义内存映射区的起始地址</p><p>还定义了一些虚拟内存与物理内存映射内容相关的统计变量。</p><p>mm_struct 结构体中的 total_vm 表示在进程虚拟内存空间中总共与物理内存映射的页的总数。</p><p>当内存吃紧的时候，有些页可以换出到硬盘上，而有些页因为比较重要，不能换出。locked_vm 就是被锁定不能换出的内存页总数，pinned_vm  表示既不能换出，也不能移动的内存页总数。</p><p>data_vm 表示数据段中映射的内存页数目，exec_vm 是代码段中存放可执行文件的内存页数目，stack_vm 是栈中所映射的内存页数目，这些变量均是表示进程虚拟内存空间中的虚拟内存使用情况。</p><p>下图为一个总览图：</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251733977.png" alt="640 (5)"></p><h3 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h3><p>内核中使用结构体 <code>vm_area_struct</code>，来管理像代码段、数据段等不同的虚拟内存区域VMA</p><p>同样在<code>include/linux/mm_types.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*定义虚拟内存区域起始地址*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_start;<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_end;<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">/*省略*/</span></span><br><span class="line"><span class="comment">/*定义访问权限*/</span></span><br><span class="line"><span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_flags;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span> <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>  <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;  <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>vm_start 指向了这块虚拟内存区域的起始地址（最低地址），vm_start 本身包含在这块虚拟内存区域内。vm_end 指向了这块虚拟内存区域的结束地址（最高地址），而 vm_end 本身包含在这块虚拟内存区域之外，所以 vm_area_struct 结构描述的是 [vm_start，vm_end) 这样一段左闭右开的虚拟内存区域。</p><p>vm_page_prot 和 vm_flags 都是用来标记 vm_area_struct 结构表示的这块虚拟内存区域的访问权限和行为规范。</p><p>接下来的三个属性 anon_vma，vm_file，vm_pgoff 分别和虚拟内存映射相关，虚拟内存区域可以映射到物理内存上，也可以映射到文件中，映射到物理内存上我们称之为匿名映射，映射到文件中我们称之为文件映射。</p><p>当我们调用 malloc 申请内存时，如果申请的是小块内存（低于 128K）则会使用 do_brk() 系统调用通过调整堆中的 brk 指针大小来增加或者回收堆内存。</p><p>如果申请的是比较大块的内存（超过 128K）时，则会调用 mmap 在上图虚拟内存空间中的文件映射与匿名映射区创建出一块 VMA 内存区域，如果进行匿名映射，其匿名映射区域就用 struct anon_vma 结构表示；如果进行文件映射，vm_file 属性就用来关联被映射的文件，vm_pgoff 则表示映射进虚拟内存中的文件内容，在文件中的偏移。</p><h3 id="将虚拟内存区域组织进虚拟内存中"><a href="#将虚拟内存区域组织进虚拟内存中" class="headerlink" title="将虚拟内存区域组织进虚拟内存中"></a>将虚拟内存区域组织进虚拟内存中</h3><p><strong>同一个进程的虚拟内存空间的不同虚拟内存区域是如何组织起来的呢？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span>  <span class="comment">//红黑树节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内核中使用两种方式对虚拟内存区域进行组织</p><p>一是通过一个 struct vm_area_struct 结构的<strong>双向链表</strong>将虚拟内存空间中的这些虚拟内存区域 VMA 串联起来的。</p><p>vm_area_struct 结构中的 vm_next ，vm_prev 指针分别指向 VMA 节点所在双向链表中的后继节点和前驱节点，内核中的这个 VMA 双向链表是有顺序的，所有 VMA 节点按照低地址到高地址的增长方向排序。双向链表中的最后一个 VMA 节点的 vm_next 指针指向 NULL，双向链表的头指针存储在内存描述符 struct mm_struct 结构中的 <strong>mmap</strong> 中，正是这个 mmap 串联起了整个虚拟内存空间中的虚拟内存区域。</p><p>二是为了高效查询，将VMA作为红黑数的节点，以红黑树来组织。</p><p>每个 VMA 区域都是红黑树中的一个节点，通过 struct vm_area_struct 结构中的 vm_rb 将自己连接到红黑树中。而红黑树中的根节点存储在内存描述符 struct mm_struct 中的 <strong>mm_rb</strong> 中</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312251734943.png" alt="640 (6)"></p><p>参考文献：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21#wechat_redirect">参考文献</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2023/12/14/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2023/12/14/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><a href="https://www.cnblogs.com/alantu2018/p/8612722.html">内容介绍</a></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INEF,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">//服务器端监听套接字</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr)); <span class="comment">//初始化addr_in类型</span></span><br><span class="line">addr.sin_family = AF_INET; <span class="comment">//IPV4</span></span><br><span class="line">addr.sin_port = hton(<span class="number">2000</span>);<span class="comment">//端口2000</span></span><br><span class="line">addr_sin_addr.s_addr = INADDR_ANY; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)); <span class="comment">//绑定陶套接字和套接口地址</span></span><br><span class="line">listen(socfd, <span class="number">5</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client,<span class="number">0</span>,<span class="keyword">sizeof</span>(client)); <span class="comment">//初始化客户端套接字</span></span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    fds[i] = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; max)</span><br><span class="line">        max = fds[i];<span class="comment">//记录最大的文件描述符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fd_set rset;</span><br><span class="line">    FD_ZERO(&amp;rest); <span class="comment">//全部置为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        FD_SET(fds[i],&amp;rset); <span class="comment">//将我们关心的文件描述符设为1</span></span><br><span class="line">    </span><br><span class="line">    select(max+<span class="number">1</span>, &amp;rest, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// select函数会将所有的文件描述符中，有数据到来的那些描述符的对应位置置位1，其余位置置位0，</span></span><br><span class="line">    <span class="comment">//通过for循环判断哪些文件描述符被置位，从而读取其中的数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], &amp;rset))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">            read(fds[i],buffer,MAXBUF); <span class="comment">//读操作</span></span><br><span class="line">            <span class="built_in">puts</span>(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用内核态来判断那个套接字描述符有数据</p><p>缺点：有1024个文件描述符的限制；fd_set不可以重用，每次循环需要重新置位0；内核态复制文件描述符导致文件描述符列表越长需要复制的次数越多；O(n)遍历判断哪个位置的描述符被置位</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll函数格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd * fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>参数：指向pollfd结构体类型的指针，数组指针</p><p>​            关注的文件描述符的个数</p><p>​             时间</p><p>poolfd结构体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="type">short</span> revents;       <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125; ; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client,<span class="number">0</span>, <span class="keyword">sizeof</span>(client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    pollfds[i].fd = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);<span class="comment">//pollfds是pollfd类型的结构体数组</span></span><br><span class="line">    pollfds[i].events = POLLIN;<span class="comment">//关注的是有数据可读事件</span></span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>); <span class="comment">//调用poll函数，pollfds[i]发生了POLLIN事件，                                                  //把pollfds[i].revents对应于POLLIN置位为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pollfds[i].revents &amp; POLLIN)  <span class="comment">//可能有多个关注事件，要与对应的事件做与操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            pollfds[i].revents = <span class="number">0</span>;<span class="comment">//复位</span></span><br><span class="line">            <span class="comment">//处理数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><a href="https://zhuanlan.zhihu.com/p/406175793">epoll函数原理详解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event events[5];</span><br><span class="line">int c = epoll_create1(10);</span><br><span class="line">int epfd = epoll_create(10);//创建一个epoll对象，返回文件描述符,参数只要大于0即可</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">for(int i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">    static struct epoll_event ev;  //临时变量</span><br><span class="line">    memset(&amp;client, 0, sizeof(client));</span><br><span class="line">    addrlen = sizeof(client);</span><br><span class="line">    ev.data.fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen); //监听的套接字文件描述符</span><br><span class="line">    ev.events = EPOLLIN; //监听事件是读事件</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    nfds = epoll_wait(epfd, events, 5, 10000);</span><br><span class="line">    for(i=0;i&lt;ndfs;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //处理数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程-Linux系统编程3</title>
      <link href="/2023/12/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/"/>
      <url>/2023/12/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统编程3"><a href="#Linux系统编程3" class="headerlink" title="Linux系统编程3"></a>Linux系统编程3</h1><h2 id="dentry和inode"><a href="#dentry和inode" class="headerlink" title="dentry和inode"></a>dentry和inode</h2><p>参考：<a href="https://bean-li.github.io/vfs-inode-dentry/">https://bean-li.github.io/vfs-inode-dentry/</a></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312031438241.png" alt="image-20231203143825104"></p><p><strong>innode：</strong></p><p>本质是结构体，<strong>存储文件的属性信息</strong>。如权限、类型、大小、时间、用户、盘块位置等。大多数的inode都存储在磁盘上，少量常用</p><p><strong>dentry：</strong></p><p>目录项，本质是结构体，存有<strong>文件名</strong>和<strong>inode指针</strong>。因此一个文件可以有多个dentry项</p><h2 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h2><p>stat函数，用于获取文件属性，即<strong>获取的就是inode的内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int stat(const char *pathname, struct stat *statbuf);</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p>path：文件路径</p><p>buf：传出参数，存放<strong>文件属性</strong></p><p><strong>返回值</strong></p><p>成功：0，失败：-1</p><p><strong>stat结构体如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">   <span class="type">dev_t</span>     st_dev;         <span class="comment">/* 设备号码 */</span></span><br><span class="line">   <span class="type">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">   <span class="type">mode_t</span>    st_mode;        <span class="comment">/* 文件模式，文件、目录 */</span></span><br><span class="line">   <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">   <span class="type">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">   <span class="type">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">   <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">   <span class="type">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">   <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">   <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>判断文件类型</strong>，使用对应函数，传入stat结构体中的st_mode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = stat(argy[<span class="number">1</span>], &amp;sb);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">perror(<span class="string">&quot;stat eror&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(sb.st_mode)) <span class="comment">//常规文件</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a regular(n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s ISDIR(sb.st mode) <span class="comment">//目录</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a dirln&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(sb.st_mode)) <span class="comment">//管道</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a pipe n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(sb.st_mode)) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a sym link n&quot;</span>); <span class="comment">//链接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="link和unlink函数"><a href="#link和unlink函数" class="headerlink" title="link和unlink函数"></a>link和unlink函数</h2><p>Linux允许多个目录项共享一个inode，即共享盘块，从而使同一个文件有多个文件名。使用link函数，可以为已经存在的目录创建目录项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int link(const char *oldname, const char *newname);</span><br></pre></td></tr></table></figure><p>使用unlink可以删除一个文件的目录项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int unlink(const char* pathname);</span><br></pre></td></tr></table></figure><p>功能详解：unlink从文件系统中中删除一个dentry，若这个dentry是指向这个文件的最后一个链接，并且没有进程处于打开这个文件的状态，则删除这个文件，释放这个文件占用的空间。若这个dentry是指向这个文件的最后一个链接，但是有进程处于打开这个文件的状态，则暂时不删除文件，等到打开这个文件的进程关闭这个文件后，系统才择机删除这个文件。</p><h2 id="opendir、readdir函数"><a href="#opendir、readdir函数" class="headerlink" title="opendir、readdir函数"></a>opendir、readdir函数</h2><p>opendir打开一个目录文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*name)</span>;</span><br></pre></td></tr></table></figure><p>DIR表示目录流类型。</p><p>opendir()用来打开参数name 指定的目录, 并<strong>返回目录流指针</strong>,（相当于文件描述符fd）</p><p>对应的关闭时<code>closedir(DIR *name)</code></p><p>readdir函数返回参数dir 目录流的下个目录进入点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct dirent *readdir(DIR *dirp);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino; //d_ino 此目录项的inode</span><br><span class="line">    ff_t d_off; //d_off  目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen; //d_reclen _name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type; //d_type d_name 所指的文件类型 d_name 文件名</span><br><span class="line">    har d_name[256];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>返回值</strong>：成功则返回<strong>下个目录项指针</strong>。读取到目录文件尾则返回NULL,error不变，读取错误的话返回NULL，并且error被设置</p><p><strong>每次读一个项，就会有目录流读取位置就会往后偏移一项，使下次使用readdir可以读下一个目录项指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR * dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">    dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dp==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp))!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,sdp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rewinddir函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void rewinddir(DIR *dir)</span><br></pre></td></tr></table></figure><p>rewinddir()用来设置参数dir 目录流目前的读取位置为原来开头的读取位置.</p><p><strong>telldir函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_t telldir(DIR *dir);</span><br></pre></td></tr></table></figure><p>telldir()返回参数dir 目录流目前的读取位置。此返回值代表距离目录文件开头的偏移量，返回值返回下个读取位置。</p><p><strong>seekdir函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void seekdir(DIR * dir, off_t offset);</span><br></pre></td></tr></table></figure><p>seekdir()用来设置参数dir 目录流目前的读取位置, 在调用readdir()时便从此新位置开始读取. 参数offset 代表距离目录文件开头的偏移量。</p><h2 id="总结：实现ls功能"><a href="#总结：实现ls功能" class="headerlink" title="总结：实现ls功能"></a>总结：实现ls功能</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_file</span><span class="params">(<span class="type">char</span> *, <span class="type">const</span> <span class="type">int</span> )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">is_file</span><span class="params">(<span class="type">char</span> *,<span class="type">const</span> <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_file</span><span class="params">(<span class="type">char</span> *name, <span class="type">const</span> <span class="type">int</span> depth)</span> <span class="comment">//目录</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dp;<span class="comment">//目录流指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span> <span class="comment">//目录项指针</span></span><br><span class="line">    <span class="keyword">if</span>((dp = opendir(name)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>) <span class="comment">//对于目录中的文件，其打开路径都是：目录路径+文件名</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">char</span> file_true_path[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">char</span> lastChar =  name[<span class="built_in">strlen</span>(name)<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(lastChar==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            <span class="built_in">sprintf</span>(file_true_path,<span class="string">&quot;%s%s&quot;</span>,name,sdp-&gt;d_name);<span class="comment">//拼接</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">sprintf</span>(file_true_path,<span class="string">&quot;%s/%s&quot;</span>,name,sdp-&gt;d_name);<span class="comment">//拼接</span></span><br><span class="line">        is_file(file_true_path,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">is_file</span><span class="params">(<span class="type">char</span> *path, <span class="type">const</span> <span class="type">int</span> depth)</span> <span class="comment">//depth为文件层次</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(stat(path, &amp;sb)==<span class="number">-1</span>) <span class="comment">//读文件属性，判断是否出错</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(sb.st_mode))<span class="comment">//目录文件,打印目录</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*depth;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">//按深度打印空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,path);</span><br><span class="line">        Read_file(path,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*depth;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">//按深度打印空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %8ld\n&quot;</span>,path, sb.st_size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)</span><br><span class="line">        is_file(<span class="string">&quot;.&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    is_file(argv[<span class="number">1</span>],<span class="number">1</span>); <span class="comment">//目录根路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重定向（dup和dup2）"><a href="#重定向（dup和dup2）" class="headerlink" title="重定向（dup和dup2）"></a>重定向（dup和dup2）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;  <span class="comment">//oldfd是已有的文件描述符</span></span><br></pre></td></tr></table></figure><p>返回值：成功返回新的文件描述符</p><p>dup函数为oldfd指向的文件创建一个新的文件描述符副本，它们指向相同的打开文件描述符（参见 open(2)），因此共享文件偏移量和文件状态标志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(argv[1],O_RDWR|O_APPEND))==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int newfd = dup(fd);  //为一个相同文件返回新的文件描述符</span><br><span class="line">    printf(&quot;newfd = %d\n&quot;,newfd);</span><br><span class="line">    </span><br><span class="line">    if (write(newfd, &quot;1234567&quot;, 7) == -1) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;write error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd, int newfd);  //oldfd是已有的文件描述符,newfd是新的文件描述符</span><br></pre></td></tr></table></figure><p><code>dup2()</code> 系统调用执行与 <code>dup()</code> 类似的任务，但是不使用未使用的最低文件描述符号，而是使用在 <code>newfd</code> 中指定的文件描述符号。如果文件描述符 <code>newfd</code> 之前已经打开，则在被重用之前会被静默关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = open(argv[<span class="number">1</span>],O_RDWR|O_APPEND))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newfd = dup2(fd,STDOUT_FILENO); <span class="comment">//标准输出的文件描述符所指向得的文件，重定向到fd所指的文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------\n&quot;</span>); <span class="comment">//向标准输出写的数据会写入txt文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程-Linux系统编程2</title>
      <link href="/2023/12/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/"/>
      <url>/2023/12/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统编程2"><a href="#Linux系统编程2" class="headerlink" title="Linux系统编程2"></a>Linux系统编程2</h1><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将<strong>现有的存取权限减掉权限掩码后</strong>，即可产生建立文件时预设的权限。</p><p>linux创建文件文件默认权限为644，目录默认权限为755，默认权限掩码为022。</p><h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><p><strong>定义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br></pre></td></tr></table></figure><p>头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p><strong>1、pathname：</strong></p><p>相对该文件的绝对路径</p><p><strong>2、flags</strong>：</p><p>flags参数表示打开文件所采用的操作</p><ul><li>O_RDONLY：只读模式</li><li>O_WRONLY：只写模式</li><li>O_RDWR：可读可写</li></ul><p>以上三个参数是<strong>必须的</strong>，下边的选项是选用的，使用时需要与必选参数<code>|</code>起来，如<code>O_RDONLY|O_CREAT</code></p><ul><li><p>O_APPEND 表示追加，如果原来文件里面有内容，则这次写入会写在文件的最末尾。</p></li><li><p>O_CREAT 如果指定文件不存在，则创建这个文件  <code>fd = open(&quot;./2.txt&quot;,O_RDONLY|O_CREAT,0644);</code></p></li><li><p>O_EXCL 表示如果要创建的文件已存在，则出错，同时返回 -1，并且修改 errno 的值。</p></li><li><p>O_TRUNC 表示截断，如果文件存在，并且以<strong>只写、读写</strong>方式打开，则将其长度截断为0。</p></li><li><p>O_NOCTTY 如果路径名指向终端设备，不要把这个设备用作控制终端。</p></li><li><p>O_NONBLOCK 如果路径名指向 FIFO&#x2F;块文件&#x2F;字符文件，则把文件的打开和后继 I&#x2F;O设置为非阻塞模式（nonblocking mode）</p></li></ul><p><strong>3、mode:</strong></p><p>mode参数表示设置文件访问权限的初始值，和用户掩码umask有关,用于创建文件时使用，即第二个参数flags为<code>O_CREAT</code>时才有用</p><p><strong>返回值</strong></p><p>正常则返回一个整数，即文件描述符（int型），出现错误返回-1，并且<code>errno</code>被设置成对应的值</p><p><strong>常见错误：</strong></p><ul><li>打开文件不存在</li><li>以写方式打开只读文件</li><li>以只写或读写方式打开目录，只能用只读方式打开目录</li></ul><h2 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// 参数：文件描述符，缓冲区指针，缓冲区大小</span></span><br></pre></td></tr></table></figure><p>成功：返回读到的字节数</p><p>错误，返回-1，设置<code>errno</code>为对应值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write() 将从 buf 开始的缓冲区中写入 count 个字节到文件描述符 fd 引用的文件。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// count为要写入的字节数</span></span><br></pre></td></tr></table></figure><p>使用read和write实现cp操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> n;  <span class="comment">//每次读到的字节数</span></span><br><span class="line"><span class="type">int</span> fd_rd = open(<span class="string">&quot;./1.txt&quot;</span>,O_RDONLY);</span><br><span class="line"><span class="type">int</span> fd_wr = open(<span class="string">&quot;./2.txt&quot;</span>,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd_rd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open read_txt error&quot;</span>);<span class="comment">//输出错误提示，并输出strerror(errno)的系统错误信息</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fd_wr == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open write_txt error&quot;</span>); </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先把数据读入缓冲区</span></span><br><span class="line"><span class="keyword">while</span>( (n = read(fd_rd,&amp;buf,<span class="keyword">sizeof</span>(buf))) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">write(fd_wr, buf, n); <span class="comment">//这里是n</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">close(fd_rd);</span><br><span class="line">close(fd_wr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312012042842.png" alt="image-20231201204236724"></p><p>PCB进程控制块，本质是结构体。其中有个指针变量，指向文件描述符表。</p><p>文件描述符表是一个数组，其中的下标0、1、2、….1023就是文件描述符，而数组中存的是每个文件的每个文件结构体file的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">文件的偏移量</span><br><span class="line">文件的访问权限</span><br><span class="line">文件的打开标志</span><br><span class="line">    文件在内核缓冲区的首地址</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><p>0-STDIN_FILENO</p><p>1-STDOUT_FILENO</p><p>2-STDERR_FILENO</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>读常规文件是不会阻塞的，不管读多少字节，read 一定会在有限的时间内返回。从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用 read 读终端设备就会阻塞，如果网络上没有接收到数据包，调用 read 从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。<br>产生阻塞的场景。设备文件、读网络文件</p><p>&#x2F;dev&#x2F;tty —–终端文件 <code>open(&quot;/dev/tty,O_RDWR|O_NONBLOCK&quot;)</code></p><h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>获取文件状态：F_GETFL <code>int flags = fctl(0,F_GETFL)</code></p><p>设置文件状态：F_SETFL  <code>fcntl(STDIN_FILENO,F_SETFL,flags)</code></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202312021229678.png" alt="image-20231202122934603"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> flags,n;</span><br><span class="line"><span class="keyword">if</span>((flags = fcntl(STDIN_FILENO,F_GETFL))==<span class="number">-1</span>) <span class="comment">//获取stdin属性信息</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flags |= O_NONBLOCK;  <span class="comment">//增加O_NONBLOCK位信息</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="keyword">if</span>((ret = fcntl(STDIN_FILENO,F_SETFL,flags))==<span class="number">-1</span>)  <span class="comment">//设置标准输入文件为非阻塞状态</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fcntl set error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tryagain:</span><br><span class="line">n = read(STDIN_FILENO,buf,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="comment">//当以非阻塞状态读文件时，如果缓冲区中没有数据，则返回-1，同时设置errno为EGAIN，因此这样判断</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno != EAGAIN)&#123;</span><br><span class="line">perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line">write(STDOUT_FILENO, <span class="string">&quot;try again\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;try again\n&quot;</span>)); <span class="comment">//向标准输出中写入try again，表示一次尝试</span></span><br><span class="line"><span class="keyword">goto</span> tryagain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果从缓冲区中读到数据，就写入标准输出文件中</span></span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h2><p>Linux系统中使用系统函数来修改文件偏移量（读写位置）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>参数<code>whence</code></p><blockquote><p>SEEK_SET:  　　从文件头部开始偏移offset个字节。  </p><p>SEEK_CUR：  　从文件当前读写的指针位置开始，增加offset个字节的偏移量。  </p><p>SEEK_END：  　文件偏移量设置为文件的大小加上偏移量字节。</p></blockquote><p>返回值</p><blockquote><p>成功：返回值是较文件起始位置向后的偏移量</p><p>失败：返回-1</p></blockquote><p>注意：打开文件后，文件的读和写使用同一个偏移位置</p><p>应用场景：</p><ul><li><p>文件打开后，文件的读和写使用同一个偏移位置</p></li><li><p>使用lseek获取文件大小</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);  <span class="comment">//获取文件大小，单位：字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;length=%d\n&quot;</span>,len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用lseek拓展文件大小；要想使文件大小真正改变，必须使用IO操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = lseek(fd, <span class="number">100</span>, SEEK_END); <span class="comment">//len增加100,此时ls -l Read.txt其大小没变</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;length=%d\n&quot;</span>,len);</span><br><span class="line">write(fd,<span class="string">&quot;\0&quot;</span>,<span class="number">1</span>);   <span class="comment">// 调用IO操作，写入磁盘。此时才发生变化</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>act -A Read.txt</code>查看文件，包括特殊字符</p><p>也可以使用<code>truncate</code>函数直接拓展，<code>truncate(char *path,  off_t length)</code></p><blockquote><p>如果文件以前大于此大小，则多余的数据将丢失。 如果之前的文件较短，则会扩展它，扩展部分读取为空字节（’\0’）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程-Linux系统编程1</title>
      <link href="/2023/11/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"/>
      <url>/2023/11/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统编程1"><a href="#Linux系统编程1" class="headerlink" title="Linux系统编程1"></a>Linux系统编程1</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><code>ctrl+a</code>:光标移到命令行最前面</p><p><code>ctrl+e</code>:光标移到命令行最后面</p><p><code>ctrl+u</code>:删除整行</p><h2 id="gcc编译的四个阶段"><a href="#gcc编译的四个阶段" class="headerlink" title="gcc编译的四个阶段"></a>gcc编译的四个阶段</h2><ul><li><p>预处理：<code>gcc -E helloworld.c -o helloworld.i</code></p></li><li><p>编译：<code>gcc -S helloworld.i -o helloworld.s</code>           <strong>编译阶段出错，会给出行号</strong></p></li><li><p>汇编：<code>gcc -c helloworld.s -o helloworld.o</code></p></li><li><p>链接：<code>gcc helloworld.o -o helloworld</code>                    <strong>链接阶段出错，会有<code>collect: error: ld</code></strong></p></li></ul><h2 id="gcc编译常用命令"><a href="#gcc编译常用命令" class="headerlink" title="gcc编译常用命令"></a>gcc编译常用命令</h2><ul><li><code>-o</code>：指定生成的文件</li><li><code>-I </code>：指定头文件的路径</li><li><code>-g</code>：编译时添加调试语句（要使用gdb调试时必须加这个参数）</li><li><code>-Wall</code>：显示所有警告信息</li><li><code>-D</code>：向当前程序中注册一个宏，如<code>gcc hello.c -D HELLO</code>就是注册了一个HELLO的宏用作开关来输出调试信息</li></ul><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><p>静态库会在链接的时候直接把库文件复制到程序中，运行的时候不再依赖库文件。以<code>.a</code>为后缀</p><p>动态库是在运行时动态加载。以<code>.so</code>为后缀</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello 编程珠玑\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> a = <span class="built_in">exp</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于这个函数，使用了math.h中的exp函数</p><p>静态链接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="type">static</span> main.c -o main -lm</span><br></pre></td></tr></table></figure><p>动态链接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -lm</span><br></pre></td></tr></table></figure><p>使用了<code>-l</code>参数，后边的<code>m</code>是<code>math.h</code>的基本名称</p><p>可以使用<code>ldd main</code>查看动态链接文件的都链接了哪些库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wufang@wufang:~/C++_base_learning$ ldd test1</span><br><span class="line">linux-vdso.so.1 (0x00007ffca1fc5000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f2cb480f000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2cb4400000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f2cb490b000)</span><br></pre></td></tr></table></figure><p>如何判断一个函数是否需要链接呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="number">3</span> 函数名</span><br></pre></td></tr></table></figure><h2 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h2><ol><li>将.c文件编译生成.o文件  <code>gcc -c add.c -o add</code></li><li>使用ar工具制作静态库 <code>ar rcs lib库名.a add.o sub.o</code></li><li>编译静态库到可执行文件中<code>gcc main.c lib库名.a -o main </code></li></ol><p>按这样三部编译出可执行文件后，会出现如下警告</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.c:<span class="number">8</span>:<span class="number">33</span>: warning: implicit declaration of function ‘add’ [-Wimplicit-function-declaration]</span><br><span class="line">    <span class="number">8</span> |         <span class="built_in">printf</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>,a,b,add(a,b));</span><br><span class="line">      |                                 ^~~</span><br><span class="line">test.c:<span class="number">9</span>:<span class="number">33</span>: warning: implicit declaration of function ‘sub’ [-Wimplicit-function-declaration]</span><br><span class="line">    <span class="number">9</span> |         <span class="built_in">printf</span>(<span class="string">&quot;%d-%d=%d\n&quot;</span>,a,b,sub(a,b));</span><br><span class="line">      |                                 ^~~</span><br><span class="line">wufang@wufang:~/C++_base_learning$ ./test</span><br></pre></td></tr></table></figure><p>这个警告告诉：<strong>对add的隐式声明</strong>，因此，我们需要额外对使用的库函数进行声明，写在一个<code>库名.h</code>文件中，文件格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYMATH_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MMYMATH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这使用了头文件首位，目的是：防止重复引入和重复定义。<a href="https://www.cnblogs.com/flowingwind/p/8304668.html">https://www.cnblogs.com/flowingwind/p/8304668.html</a></p><p>制作好.h文件后，在.cpp文件中引入.h头文件（<code>#include &quot;mymath.h&quot;</code>）。此时的编译命令为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c ./lib/lib库名.a -o main.out -I ./inc</span><br></pre></td></tr></table></figure><p>静态库文件放在lib中，头文件放在inc中</p><h2 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h2><p>参考：<a href="https://cloud.tencent.com/developer/article/1711778">https://cloud.tencent.com/developer/article/1711778</a></p><ol><li><p>将.c文件编译生成与位置无关的二进制文件：<code>gcc -c add.c -o add.o -fPIC </code></p></li><li><p>使用<code>gcc -shared</code>制作动态库：<code>gcc -shared -o lib库名.so add.o sub.o div.o</code></p></li><li><p>编译可执行程序，指定所使用的动态库。 <code>-l</code>指定库名，<code>-L</code>指定动态库路径, <code>-I</code>指定库的头文件路径</p><p><code>gcc test.c -o test.out -l库名 -L./lib -I ./inc</code></p></li></ol><p><strong>注意：-l后边紧跟库名，-L后紧跟库路径，空格可有可无</strong></p><p>按上边步骤完成后，运行可执行文件，报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wufang@wufang:~/C++_base_learning/dynamic$ gcc test.c -o test.out -lmymath -L./lib -I./inc</span><br><span class="line">wufang@wufang:~/C++_base_learning/dynamic$ ./test.out </span><br><span class="line">./test.out: error <span class="keyword">while</span> loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>这个报错是因为<strong>动态链接器</strong>在运行程序的时候找不到需要链接的库。解决办法有三种，如下给出视频中的方法：</p><p>即 将动态库的路径写入<strong>用户终端配置文件</strong><code>.bashrc</code>中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bachrc  <span class="comment">#打开用户自己的终端配置文件</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=....  <span class="comment">#添加链接路径，最好使用绝对路径</span></span><br><span class="line"><span class="built_in">source</span> .bashrc   <span class="comment">#运行生效</span></span><br></pre></td></tr></table></figure><p>解决方法合集：<a href="https://www.jianshu.com/p/a3b2b6f5f0fc">https://www.jianshu.com/p/a3b2b6f5f0fc</a></p><h2 id="gdb调试工具"><a href="#gdb调试工具" class="headerlink" title="gdb调试工具"></a>gdb调试工具</h2><p>基础指令：</p><ul><li><code>-g</code>：使用该参数编译可执行文件，得到调试表</li><li><code>gdb ./a.out</code>：</li><li><code>set listsize 行数</code>：设置list打印行数</li><li><code>list 1</code>：从第一行开始打印</li><li><code>b/break</code>：设置断点，后边可以跟着行号或者函数名</li><li><code>run</code>：直接运行程序，如果设置断点了，会运行到断点，如果程序出错了，会直接运行到出错位置</li><li><code>s/step</code>：下一条指令（会进入函数）</li><li><code>n/next</code>：下一条指令（越过函数）</li><li><code>finish</code>：进入函数后，结束当前函数调用，即退出该函数</li><li><code>p/print</code>：p i 查看变量i的值</li><li><code>c/continue</code>：运行程序到下一个断点或者结束</li><li><code>quit</code>：退出gdb</li></ul><p>其它指令：</p><ul><li><p><code>start</code>：从main函数的第一行开始</p></li><li><p><code>set args</code>：设置main函数命令行参数</p></li><li><p><code>info b</code>：查看所有断点信息</p></li><li><p><code>b 20 if i = 5</code>设置条件断点，用在循环语句，嵌套递归中</p></li><li><p><code>bt</code>：查看程序中正在存活的栈帧</p></li><li><p><code>fram 栈帧编号</code>：切换栈帧</p></li><li><p><code>display 变量</code>：跟踪变量</p></li><li><p><code>undisplay 变量编号</code>：取消跟踪</p></li></ul><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h3><p>test.c中是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将函数声明写在了main函数中，后续会给出将函数声明写在.h中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">14</span>, b = <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>,a,b,add(a,b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-%d=%d\n&quot;</span>,a,b,sub(a,b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1个规则：</strong></p><p>目标：依赖条件</p><p>​（一个Tab缩进）命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o add.o sub.o</span></span><br><span class="line">        gcc test.o add.o sub.o -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c test.c -o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">        gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">        gcc -c sub.c -o sub.o</span><br></pre></td></tr></table></figure><p>基本原则：</p><ol><li>若想生成目标文件，检查规则中的依赖条件是否存在，如不存在，则寻找是否有规则用来生成该依赖文件</li><li>检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任何一项被更新，则目标更新</li></ol><p><strong>2个函数：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>   <span class="comment">#找到当前目录下所有后缀未.c的文件，赋值给src</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o <span class="variable">$(src)</span>)</span>  <span class="comment">#将src变量中包含.c后缀的文件都替换成.o后缀</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:@(obj)</span></span><br><span class="line">        gcc @(obj) -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c test.c -o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">        gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">        gcc -c sub.c -o sub.o</span><br><span class="line">        </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> test   <span class="comment">#将生成的.o文件和可执行文件都删了，rm前的&quot;-&quot;表示出错依然执行</span></span><br></pre></td></tr></table></figure><p><strong>3个变量：</strong></p><blockquote><p>$@：在一条规则的<strong>命令</strong>中，表示该规则的目标</p><p>$^：在一条规则的命令中使用，用于表示这条规则的所有依赖条件</p><p>$&lt;：在一条规则的命令中使用，用于表示这条规则的依赖条件列表中的第一个依赖条件</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>  </span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(obj)</span></span></span><br><span class="line">gcc <span class="variable">$^</span>  -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o sub.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> test</span><br></pre></td></tr></table></figure><p><strong>模式规则：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o test.o</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o add.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o sub.o</span><br><span class="line"><span class="comment"># 可以将上面的结构重复的代码做如下替换</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>最终的makefile代码可以这样写</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>  </span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">CXX = gcc  <span class="comment">#编译器，可以根据需要改成g++</span></span><br><span class="line">myArgs = -Wall -g <span class="comment">#调试选项，使得编译的文件可以进行调试</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(obj)</span></span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean  #伪目标，因为文件夹中可能存在同名的clean文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> test</span><br></pre></td></tr></table></figure><h3 id="重构版"><a href="#重构版" class="headerlink" title="重构版"></a>重构版</h3><p>项目文件夹下有如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc       makefile  obj       src</span><br></pre></td></tr></table></figure><p>其中，<code>inc</code>文件夹存放<code>头文件</code>，<code>src</code>文件夹存放<code>.c或者.cpp源代码</code>，<code>obj</code>文件夹存放<code>.o目标文件</code></p><p><code>makefile</code>文件如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./src/*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> ./src/%.c, ./obj/%.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">inc_path = ./inc  <span class="comment">#头文件所在位置</span></span><br><span class="line">myArgs = -Wall -g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(obj)</span></span></span><br><span class="line">        gcc <span class="variable">$^</span> -o test <span class="variable">$(myArgs)</span></span><br><span class="line">        </span><br><span class="line"><span class="variable">$(obj)</span>:./obj%.o:./src%.c</span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span> -I <span class="variable">$(inc_path)</span>  <span class="comment">#在编译生成目标文件时需要指出头文件位置</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        -rm -rf <span class="variable">$(obj)</span> test</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tinyhttpd第二弹</title>
      <link href="/2023/11/26/Tinyhttpd%E7%AC%AC%E4%BA%8C%E5%BC%B9/"/>
      <url>/2023/11/26/Tinyhttpd%E7%AC%AC%E4%BA%8C%E5%BC%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Tinyhttpd第二弹"><a href="#Tinyhttpd第二弹" class="headerlink" title="Tinyhttpd第二弹"></a>Tinyhttpd第二弹</h1><h2 id="补知识：http报文详解"><a href="#补知识：http报文详解" class="headerlink" title="补知识：http报文详解"></a>补知识：http报文详解</h2><p><a href="https://developer.aliyun.com/article/492403">https://developer.aliyun.com/article/492403</a></p><p><a href="https://www.cnblogs.com/huansky/p/14007810.html">https://www.cnblogs.com/huansky/p/14007810.html</a></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311242130882.webp" alt="1843940-d3214aa6ebf47292"></p><h2 id="查看GET请求"><a href="#查看GET请求" class="headerlink" title="查看GET请求"></a>查看GET请求</h2><p>我这里拿firefox访问这个我们已运行的http服务器，访问<code>http://127.0.0.1:4000/</code>地址，</p><p>F12，并选择<code>网络</code>模块，刷新页面</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311261644287.png" alt="image-20231126164354197"></p><p>第一个就是我们发出的get请求，点击后看到这样</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311261645403.png" alt="image-20231126164504365"></p><p>因为浏览器帮我们把一些东西整理了，因此需要点击<code>原始</code>才能查看真正的请求格式。如下就是请求头的格式（请求行+请求头）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1</span><br><span class="line">Host: 127.0.0.1:4000</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: none</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311261647010.png" alt="image-20231126164712965"></p><p>上图的第三个模块<code>请求</code>是展示请求体的内容，因为这是get请求，没有请求体，所以为空</p><p>接着我们看一下响应长什么样</p><p>点击上上图<code>响应头（68字节）</code>旁边的<code>原始</code>，查看响应头（相应行+响应头）的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1 200 OK</span><br><span class="line">Server: jdbhttpd/0.1.0</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure><p>那响应体呢？下图就是响应体的内容了，我们看到是html页面</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311261649058.png" alt="image-20231126164952027"></p><h2 id="查看POST请求"><a href="#查看POST请求" class="headerlink" title="查看POST请求"></a>查看POST请求</h2><p>因为我们页面中的颜色修改的请求，是通过POST发出的，所以我们基于此来看一下POST请求长什么样</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311261651818.png" alt="image-20231126165155784"></p><p>随便写一个颜色，并点击<code>Submit Query</code>, 按照上边的方法，看到POST请求长这样：</p><p>请求头（请求行+请求头）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /color.cgi HTTP/1</span><br><span class="line">Host: 127.0.0.1:4000</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line">Origin: http://127.0.0.1:4000</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://127.0.0.1:4000/</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>请求体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color=green</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tinyhttpd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++语法基础第一弹</title>
      <link href="/2023/11/24/C++%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
      <url>/2023/11/24/C++%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="C-语法基础第一弹"><a href="#C-语法基础第一弹" class="headerlink" title="C++语法基础第一弹"></a>C++语法基础第一弹</h1><h2 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h2><p>第一步提供<strong>类声明</strong>，包括<strong>数据成员</strong>和<strong>函数成员</strong>。通常<strong>数据成员被放在私有部分</strong>中，<strong>成员函数被放在公有部分</strong>，写在<code>ClassName..h</code>文件中，格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>第二步是<strong>实现</strong>类的成员函数，可以在类的声明中直接写函数的实现，但是通常的做法是<strong>单独提供函数的实现</strong>。在这种情况下，需要使用<strong>作用域解析运算符</strong><code>::</code>指出成员函数属于哪个类,写在<code>ClassName.cpp</code>文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ClassName.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassName::sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> ClassName:<span class="built_in">show</span>()</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>知识点：</strong></p><ul><li>在实现类的方法时，需要用到作用域解析运算符<code>::</code></li><li>类方法可以访问类的私有成员，无论是私有变量还是私有函数</li><li>函数声明&#x3D;函数原型，函数定义&#x3D;函数实现</li><li>同一个类的所有对象都有自己的存储空间，用于存储其内部变量和类成员，但是同一个类的所有对象共享一组类方法，每种方法只有一个副本</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>拿Stock类举例，要写它的构造函数，则<strong>函数声明</strong>如下,写在类声明的public中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stock</span>(<span class="type">const</span> string &amp; co, <span class="type">long</span> n, <span class="type">double</span> pr)  <span class="comment">//构造函数的函数名与类名一致</span></span><br></pre></td></tr></table></figure><p><strong>函数实现</strong>如下，写在<code>Stock.cpp</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> string &amp; co, <span class="type">long</span> n, <span class="type">double</span> pr)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>构造函数的参数名字不能与类成员名一样</strong></p><p>构造函数如何使用呢，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式调用</span></span><br><span class="line">Stock food = <span class="built_in">Stock</span>(<span class="string">&quot;sss&quot;</span>,<span class="number">12</span>,<span class="number">2.12</span>);</span><br><span class="line"><span class="comment">// 隐式调用</span></span><br><span class="line"><span class="function">Stock <span class="title">food</span><span class="params">(<span class="string">&quot;sss&quot;</span>,<span class="number">12</span>,<span class="number">2.12</span>)</span></span>;</span><br><span class="line"><span class="comment">// C++11后支持初始化列表</span></span><br><span class="line">Stock food=&#123;<span class="string">&quot;sss&quot;</span>,<span class="number">12</span>,<span class="number">2.12</span>&#125;;</span><br></pre></td></tr></table></figure><p>默认构造函数是在未提供初始值时，用来创建对象的构造函数。当程序员没有给一个类写构造函数时，由编译器给它提供默认构造函数，而当程序员给类定义了构造函数时，就必须为它提供默认构造函数。默认构造函数有两种方式，<strong>建议使用第二种</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给已有的构造函数的所有参数提供默认值</span></span><br><span class="line"><span class="built_in">Stock</span>(<span class="type">const</span> string &amp; co=<span class="string">&quot;wqwq&quot;</span>, <span class="type">long</span> n=<span class="number">0</span>, <span class="type">double</span> pr=<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// 利用运算符重载，另外定义一个没有参数的构造函数，然后在这个函数的函数体内进行类成员变量的初始化,叫做隐式初始化</span></span><br><span class="line"><span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">comany = <span class="string">&quot;wqwq&quot;</span>;</span><br><span class="line"><span class="type">long</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> pr = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用默认构造函数，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock food; <span class="comment">//调用默认构造函数</span></span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>对象过期时，会调用析构函数来进行清理工作，程序员不写的话，编译器会自己生成一个。</p><p>声明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Stock</span>()</span><br></pre></td></tr></table></figure><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stock::~<span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>现在有一个场景，<strong>想要比较两个Stock对象的total_val值。</strong>(类似于&gt;运算符的重载)</p><p>声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Stock &amp; <span class="title">topval</span><span class="params">(<span class="type">const</span> Stock &amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在C++中对于自定义的类型（这里是Stock类）的形参，要使用引用，从而避免大量的拷贝操作，因此参数是Stock &amp; s，而防止修改s对应的对象，使用const</span></span><br><span class="line"><span class="comment">括号后的const的意思是：这个函数不能通过this修改对象的值，</span></span><br><span class="line"><span class="comment">函数名是topval</span></span><br><span class="line"><span class="comment">由于该函数需要返回两个const返回类型是const Stock &amp; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this是指针，为调用它的对象的地址</span></span><br><span class="line"><span class="function"><span class="type">const</span> Stock &amp; <span class="title">topval</span><span class="params">(<span class="type">const</span> Stock &amp; s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.total_val&gt;total_val)</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">//返回的是调用对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个函数的实现部分，我刚开始有个疑惑的点：私有变量<code>total_val</code>不是只能通过成员函数来访问吗，为什么可以直接<code>s.total_val</code>呢？</p><p>我首先编写代码在main中使用<code>s.total_val</code>，编译的时候报错，并且报错提示给的也是：<code>total_val是私有变量</code>，那说明私有变量确实是只能通过成员函数来访问。</p><p>但是这也不在s的类内部啊，怎么s能访问<code>total_val</code>呢？</p><p>猜测是因为类中的成员函数在内存中只有一份副本</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用&amp;"></a>引用&amp;</h2><p>引用是给对象起的别名，引用本身不是一个对象，不能定义引用的引用</p><p>引用的类型和与之绑定的对象严格匹配</p><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><ul><li><p>默认情况下，const对象只在文件内有效</p></li><li><p>const修饰的常量不能被修改</p></li><li><p>const常量在创建时，必须初始化</p></li></ul><p><strong>指针与const</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * a; <span class="comment">//指向const对象的指针，即指向常量的指针</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * a;</span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向char类型的const指针，即常指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向const对象的const指针</span></span><br></pre></td></tr></table></figure><blockquote><p><em>const</em>位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于<code>*</code>的右侧，<em>const</em>就是修饰指针本身，即指针本身是常量。</p></blockquote><p><strong>函数中使用const</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++语法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tinyhttpd第一弹</title>
      <link href="/2023/11/23/Tinyhttpd%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
      <url>/2023/11/23/Tinyhttpd%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Tinyhttpd第一弹"><a href="#Tinyhttpd第一弹" class="headerlink" title="Tinyhttpd第一弹"></a>Tinyhttpd第一弹</h1><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311241425790.png" alt="1447456-20180916110843626-688018029"></p><h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><p>在<code>simpleclient.c</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> <span class="comment">//address是服务器的网络通信的地址</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    address.sin_family = AF_INET;  </span><br><span class="line">    address.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    address.sin_port = htons(<span class="number">9734</span>);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    result = connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) <span class="comment">//连接失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;oops: client1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(sockfd, &amp;ch, <span class="number">1</span>);  <span class="comment">//向套接字写入1个字符，传给服务器</span></span><br><span class="line">    read(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char from server = %c\n&quot;</span>, ch);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(sockcd,(sockaddr*)&amp;seraddr,sizeof(seraddr))</span><br></pre></td></tr></table></figure><blockquote><p>参数说明：</p><p>sockcd为客户端建立socket函数的返回值。</p><p>addr是一个sockaddr结构的指针，用于指定所要连接的服务器的地址（服务端的IP地址和端口号，要和服务端的实际IP地址以及绑定的端口一致才可以）。</p><p>addrlen为addr变量的大小，可由 sizeof()计算得出。</p></blockquote><p>对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，不是这个函数完成的，<strong>这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接</strong>（三次握手详情，请看《浅谈 TCP 三次握手》），<strong>最后把连接的结果返回给这个函数的返回值</strong>（成功连接为0， 失败为-1）。<br>通常的情况，客户端的 connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回（正常的情况，这个过程很快完成）</p><h2 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> server_sock = <span class="number">-1</span>;</span><br><span class="line">    u_short port = <span class="number">4000</span>;    <span class="comment">//服务器运行在4000端口</span></span><br><span class="line">    <span class="type">int</span> client_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_name</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span>  client_name_len = <span class="keyword">sizeof</span>(client_name);`</span><br><span class="line">    <span class="type">pthread_t</span> newthread;</span><br><span class="line"></span><br><span class="line">    server_sock = startup(&amp;port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;httpd running on port %d\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        client_sock = accept(server_sock,</span><br><span class="line">                (<span class="keyword">struct</span> sockaddr *)&amp;client_name,</span><br><span class="line">                &amp;client_name_len);</span><br><span class="line">        <span class="keyword">if</span> (client_sock == <span class="number">-1</span>)</span><br><span class="line">            error_die(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="comment">/* accept_request(&amp;client_sock); */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;newthread , <span class="literal">NULL</span>, (<span class="type">void</span> *)accept_request, (<span class="type">void</span> *)(<span class="type">intptr_t</span>)client_sock) != <span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(server_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">accept</span> <span class="params">(<span class="type">int</span> __fd, __SOCKADDR_ARG __addr,<span class="type">socklen_t</span> *__restrict __addr_len)</span>;</span><br></pre></td></tr></table></figure><p>sockfd是由socket函数返回的套接字描述符，参数addr和addrlen用来返回已连接的对端进程（客户端）的协议地址。*<strong>如果我们对客户端的协议地址不感兴趣，可以把arrd和addrlen均置为空指针</strong></p><p>返回值是一个新的socket描述符，描述与客户端的连接</p><h2 id="startup"><a href="#startup" class="headerlink" title="startup"></a>startup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> httpd = <span class="number">0</span>;   <span class="comment">//套接字描述符</span></span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span>  <span class="comment">//ip+port</span></span><br><span class="line"></span><br><span class="line">    httpd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (httpd == <span class="number">-1</span>)</span><br><span class="line">        error_die(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));</span><br><span class="line">    name.sin_family = AF_INET;</span><br><span class="line">    name.sin_port = htons(*port);</span><br><span class="line">    name.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span> ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on))) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        error_die(<span class="string">&quot;setsockopt failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bind(httpd, (<span class="keyword">struct</span> sockaddr *)&amp;name, <span class="keyword">sizeof</span>(name)) &lt; <span class="number">0</span>)</span><br><span class="line">        error_die(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (*port == <span class="number">0</span>)  <span class="comment">/* if dynamically allocating a port */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">socklen_t</span> namelen = <span class="keyword">sizeof</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (getsockname(httpd, (<span class="keyword">struct</span> sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span>)</span><br><span class="line">            error_die(<span class="string">&quot;getsockname&quot;</span>);</span><br><span class="line">        *port = ntohs(name.sin_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(httpd, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        error_die(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>(httpd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>httpd是套接字描述符</p><h3 id="sockaddr-in"><a href="#sockaddr-in" class="headerlink" title="sockaddr_in"></a>sockaddr_in</h3><p><code>sockaddr_in</code>在<code>netinet/in.h</code>中定义，将<code>port</code>和<code>addr</code>分开存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="type">in_port_t</span> sin_port;<span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr)</span><br><span class="line">   - __SOCKADDR_COMMON_SIZE</span><br><span class="line">   - <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>)</span><br><span class="line">   - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h3><p>作用：创建一个socket，返回一个<strong>socket描述符</strong>，下面是socket描述符的解释</p><blockquote><p>当应用程序要创建一个套接字时，操作系统就返回一个 <strong>小整数</strong> 作为描述符，应用程序则使用这个描述符来引用该套接字。</p></blockquote><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol);</span><br><span class="line">参数说明：</span><br><span class="line">domain：指定协议族，常用 AF_INET，表示 IPv4 网络协议。</span><br><span class="line">type：指定 Socket 类型，常用 SOCK_STREAM，表示使用面向连接的 TCP 协议。</span><br><span class="line">protocol：指定协议类型，常用 <span class="number">0</span>，系统根据 domain 和 type 自动选择合适的协议。</span><br><span class="line">返回值： </span><br><span class="line">成功：返回一个 socket 描述符，可以用于后续连接和通信操作。</span><br><span class="line">失败：返回 <span class="number">-1</span>，并设置 errno 错误码。</span><br></pre></td></tr></table></figure><h3 id="setsockopt-函数"><a href="#setsockopt-函数" class="headerlink" title="setsockopt()函数"></a>setsockopt()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __setsockopt64 (<span class="type">int</span> __fd, <span class="type">int</span> __level, <span class="type">int</span> __optname,</span><br><span class="line">   <span class="type">const</span> <span class="type">void</span> *__optval, <span class="type">socklen_t</span> __optlen) __THROW;</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> setsockopt __setsockopt64</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><blockquote><p>sock：将要被设置的套接字描述符。<br>level：选项所在的协议层。</p><ul><li>SOL_SOCKET:通用套接字选项.</li><li>IPPROTO_IP:IP选项.</li><li>IPPROTO_TCP:TCP选项.</li></ul><p>　</p><p>optname：需要访问的选项名。</p><ul><li>SO_REUSERADDR　允许重用本地地址和端口</li></ul><p>optval：选项value值。<br>optlen：选项的长度。</p></blockquote><p>返回：</p><blockquote><p>成功执行时，返回0。失败返回-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on)</span><br></pre></td></tr></table></figure><p>这里使用了<code>SO_REUSEADDR</code>，端口复用。</p><p>端口复用最常用的用途应该是<strong>防止服务器重启时之前绑定的端口还未释放或者程序突然退出而系统没有释放端口</strong>。这种情况下如果设定了端口复用，则新启动的服务器进程可以直接绑定端口。如果没有设定端口复用，绑定会失败，提示ADDR已经在使用中</p><p>在TCP断开链接的时候我们需要四次握手来断开，而且当两端都关闭了read&#x2F;write通道以后我们还是要等待一个TIME_WAIT时间。而使用SO_REUSEADDR是让端口释放后立即就可以被再次使用。</p><blockquote><p>SO_REUSEADDR可以用在以下四种情况下。<br>(摘自《Unix网络编程》卷一，即UNPv1)<br>1、当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启<br>动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。<br>2、SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但<br>每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可<br>以测试这种情况。<br>3、SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个soc<br>ket绑定的ip地址不同。这和2很相似，区别请看UNPv1。<br>4、SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的<br>多播，不用于TCP。</p><p>链接：<a href="https://www.jianshu.com/p/711be2f1ec6a">https://www.jianshu.com/p/711be2f1ec6a</a></p></blockquote><h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数形式：</span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *my_addr, <span class="type">socklen_t</span> addrlen)</span></span><br><span class="line">返回值：</span><br><span class="line">成功：0， 失败：-1</span><br></pre></td></tr></table></figure><p>当调用socket函数创建套接字后，该套接字并没有与本机地址和端口等信息相连，bind函数将完成这些工作。bind函数中的sockfd参数为调用socket函数后返回的文件描述符。my_addr参数为指向sockaddr结构体的指针（该结构体中保存有端口和IP地址信息）。addlen参数为结构体sockaddr的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)</span><br></pre></td></tr></table></figure><p><strong>疑问：虽然知道sockaddr_in是<code>网络套接字地址</code>,socksddr是<code>通用套接字地址</code>。但是还是不懂name是sockaddr_in类型，为什么这里写的是sockaddr类型？</strong></p><h3 id="getsockname-函数"><a href="#getsockname-函数" class="headerlink" title="getsockname()函数"></a>getsockname()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *localaddr,<span class="type">socklen_t</span> *addrlen)</span></span><br></pre></td></tr></table></figure><p>当以端口号0调用bind（告诉内核去选择本地端口号）后，getsockname用于返回由内核赋予的本地端口号</p><h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen()函数"></a>listen()函数</h3><p>对于服务器，它是被动连接的。举一个生活中的例子，通常的情况下，移动的客服（相当于服务器）是等待着客户（相当于客户端）电话的到来。而这个过程，需要调用listen()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p>listen() 函数的主要作用就是将套接字( sockfd )变成被动的连接监听套接字（被动等待客户端的连接），至于参数 backlog 的作用是设置内核中连接队列的长度，TCP 三次握手也不是由这个函数完成，listen()的作用仅仅告诉内核一些信息。只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而<strong>这个连接的过程是由内核完成</strong>.<br><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311241426663.png" alt="20150510163636791"></p><p>参考链接：<a href="https://blog.csdn.net/tennysonsky/article/details/45621341">https://blog.csdn.net/tennysonsky/article/details/45621341</a></p><h2 id="get-line"><a href="#get-line" class="headerlink" title="get_line"></a>get_line</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((i &lt; size - <span class="number">1</span>) &amp;&amp; (c != <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        n = recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//套接字、缓冲区、缓冲区大小、0，char类型是一个字节，故第三个参数是1</span></span><br><span class="line">        <span class="comment">//返回值是copy的字节数</span></span><br><span class="line">        <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>) <span class="comment">//回车符：光标移到当前行的开始，不换行</span></span><br><span class="line">            &#123;</span><br><span class="line">                n = recv(sock, &amp;c, <span class="number">1</span>, MSG_PEEK); </span><br><span class="line"><span class="comment">// 函数从套接字 sock 中接收数据，但是不移除接收到的数据，而是通过 MSG_PEEK 标志来查看当前可用的数据。</span></span><br><span class="line">                <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></span><br><span class="line">                <span class="comment">// 下一个字符是换行符，那就再把它读出来，并且这个两个字符\r\n都不保存，直接退出函数</span></span><br><span class="line">                <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">                    recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 下一个字符不是换行符，那也满足是“回车符”的条件，依旧不保存字符，退出函数</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个字符不是回车符，就可以直接保存到缓冲区中</span></span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(i);</span><br><span class="line">&#125;<span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((i &lt; size - <span class="number">1</span>) &amp;&amp; (c != <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        n = recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//套接字、缓冲区、缓冲区大小、0</span></span><br><span class="line">        <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n = recv(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</span><br><span class="line">                <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></span><br><span class="line">                <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">                    recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getline()函数用于从socket中读取一行数据</p><h3 id="recv-函数"><a href="#recv-函数" class="headerlink" title="recv()函数"></a>recv()函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int recv( SOCKET s, char FAR *buf, int len, int flags); </span><br></pre></td></tr></table></figure><blockquote><p>第一个参数指定接收端套接字描述符；</p><p>第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</p><p>第三个参数指明buf的长度；</p><p>第四个参数一般置0。</p><p>recv函数返回其实际copy的字节数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tinyhttpd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vscode调试Linux内核</title>
      <link href="/2023/11/20/Vscode%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8/"/>
      <url>/2023/11/20/Vscode%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Vscode调试Linux内核"><a href="#使用Vscode调试Linux内核" class="headerlink" title="使用Vscode调试Linux内核"></a>使用Vscode调试Linux内核</h1><p>上一篇博客我们在虚拟机中编译了Linux内核，并且使用Qemu和gdb进行调试，但是gdb的指令我还不熟练，还是想用vscode来调试，这样也更加方便</p><h2 id="Vscode插件安装"><a href="#Vscode插件安装" class="headerlink" title="Vscode插件安装"></a>Vscode插件安装</h2><h3 id="remote-ssh"><a href="#remote-ssh" class="headerlink" title="remote-ssh"></a>remote-ssh</h3><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201245007.png" alt="image-20231120124509960"></p><p>安装完成后右边工具栏会多出一个功能</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201246229.png" alt="image-20231120124653194"></p><p>按F1呼出对话框，输入<code>remote-ssh</code>，选择open ssh configuration file。</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201247886.png" alt="image-20231120124748850"></p><p>选择第一个配置文件</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201248231.png" alt="image-20231120124824202"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host 自定义连接名称</span><br><span class="line">    HostName 服务器IP地址</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><h3 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h3><p>安装C&#x2F;C++插件</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201251048.png" alt="image-20231120125110014"></p><p>依次点击【运行】-&gt;【打开配置】，将以下配置复制到launch.json中。</p><p><strong>该代码不需要更改，直接粘贴</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kernel-debug&quot;</span><span class="punctuation">,</span>   <span class="comment">//随便起名</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:1234&quot;</span><span class="punctuation">,</span>  <span class="comment">//远端调试地址，1234为qemu的监视端口</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/vmlinux&quot;</span><span class="punctuation">,</span>     <span class="comment">//当前目录下的vmlinux</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;engineLogging&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Vscode调试"><a href="#Vscode调试" class="headerlink" title="Vscode调试"></a>Vscode调试</h2><h3 id="在虚拟机中启动qemu"><a href="#在虚拟机中启动qemu" class="headerlink" title="在虚拟机中启动qemu"></a>在虚拟机中启动qemu</h3><p>在<strong>Linux内核文件夹下</strong>运行此命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./arch/x86/boot/bzImage -initrd ../initramfs.cpio.gz -append <span class="string">&quot;nokaslr console=ttyS0&quot;</span> -s -S -nographic</span><br></pre></td></tr></table></figure><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p>打开init&#x2F;main.c，我打了如下的断点</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201300424.png" alt="image-20231120130037370"></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201305050.png" alt="image-20231120130522009"></p><p>然后在vscode中就可以看到调试结果了</p><h2 id="代码中标红的问题"><a href="#代码中标红的问题" class="headerlink" title="代码中标红的问题"></a>代码中标红的问题</h2><p>代码标红是缺少compile_commands.json文件</p><p>我在B站上学习的时候，是跟着这位up主来的（源码被猫吃了），他的解决方案如下：</p><p>在终端键入命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/clang-tools/gen_compile_commands.py</span><br></pre></td></tr></table></figure><p>在源码目录下就生成了<code>compile_commands.json</code>文件</p><p>在vscode中：<code>ctrl+shipt+p</code>选择C&#x2F;C++：Edit Coonfigurations,</p><p>在c_cpp_properties.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compileCommands&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/compile_commands.json&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此后，main.c中的代码就不标红了</p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用虚拟机进行基于qemu和gdb的Linux内核调试</title>
      <link href="/2023/11/20/%E9%85%8D%E7%BD%AELinux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%911/"/>
      <url>/2023/11/20/%E9%85%8D%E7%BD%AELinux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%911/</url>
      
        <content type="html"><![CDATA[<h1 id="使用虚拟机进行基于qemu和gdb的Linux内核调试"><a href="#使用虚拟机进行基于qemu和gdb的Linux内核调试" class="headerlink" title="使用虚拟机进行基于qemu和gdb的Linux内核调试"></a>使用虚拟机进行基于qemu和gdb的Linux内核调试</h1><h2 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><p>至少分8个核心（不然编译速度很慢，亲测）</p><p>磁盘大小分50G（编译后的内核大小有20多个G！）</p><h2 id="打开SSH"><a href="#打开SSH" class="headerlink" title="打开SSH"></a>打开SSH</h2><p>虚拟机中安装的是ubuntu22.04版本，默认没有安装和启用SSH服务</p><p><strong>更新软件源</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure><p><strong>安装SSH(OpenSSH)</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server -y</span><br></pre></td></tr></table></figure><p><strong>启动SSH服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now ssh</span><br></pre></td></tr></table></figure><p><strong>检查是否启动成功</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status ssh</span><br></pre></td></tr></table></figure><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装相关依赖</span></span><br><span class="line">sudo apt-get install libncurses5-dev libssl-dev bison flex libelf-dev gcc g++ make openssl libc6-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装gdb，这里使用apt安装（多次尝试的结果）</span></span><br><span class="line">sudo apt-get install gdb</span><br><span class="line">gdb --version <span class="comment"># gdb版本为12.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里选择清华源，国内速度会快很多</span></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.14.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xvf linux-5.14.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置编译选项</span></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>然后会在此文件夹下生成 <strong>.&#x2F;config</strong>文件</p><p><strong>进入该文件，并做以下2处修改</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./.config</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201128412.png" alt="image-20231117212013850"></p><p><strong>安装dwarves软件包（编译报错得出结论）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dwarves</span><br></pre></td></tr></table></figure><p><strong>BTF报错解决</strong></p><p>如果仅仅只进行了上边的配置，会报如下错误（我个人是这样）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  KSYMS   .tmp_vmlinux.kallsyms1.S</span><br><span class="line">  AS      .tmp_vmlinux.kallsyms1.S</span><br><span class="line">  LD      .tmp_vmlinux.kallsyms2</span><br><span class="line">  KSYMS   .tmp_vmlinux.kallsyms2.S</span><br><span class="line">  AS      .tmp_vmlinux.kallsyms2.S</span><br><span class="line">  LD      vmlinux</span><br><span class="line">  BTFIDS  vmlinux</span><br><span class="line">FAILED: load BTF from vmlinux: Invalid argument</span><br><span class="line">make: *** [Makefile:1187: vmlinux] Error 255</span><br><span class="line">make: *** Deleting file <span class="string">&#x27;vmlinux&#x27;</span></span><br></pre></td></tr></table></figure><p>查阅资料后，有三种解决方案：<a href="https://devkernel.io/posts/pahole-error/">https://devkernel.io/posts/pahole-error/</a></p><p>我使用的是<strong>第二种方法</strong>，对pahole软件包进行降级 :</p><p>查看pahole的版本，是1.25</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pahole --version  </span><br></pre></td></tr></table></figure><p>查看pahole的所有可用安装版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache policy pahole</span><br></pre></td></tr></table></figure><p>截图如下</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201127209.png" alt="1"></p><p>我们发现只有两个版本，因此只能降级为 1.22-8</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pahole=1.22-8</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8      <span class="comment">#8个线程并行编译，</span></span><br></pre></td></tr></table></figure><p>然后可能会弹出一个选择（1，2，3），直接选择1即可。等待一段时间，30分钟左右</p><h3 id="是否成功"><a href="#是否成功" class="headerlink" title="是否成功"></a>是否成功</h3><p>编译完成后，目录下会生成以下,那么就编译成功了</p><blockquote><p>.&#x2F;vmLinux</p><p>.&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage</p><p>其中vmLinux为GDB所需的调试Map文件，bzImage为大内核文件</p></blockquote><h2 id="安装Qemu"><a href="#安装Qemu" class="headerlink" title="安装Qemu"></a>安装Qemu</h2><p>qemu是一款完全软件模拟(Binary translation)的虚拟化软件，在虚拟化的实现中性能相对较差。但利用它在测试环境中gdb调试Linux内核代码，是熟悉Linux内核代码的一个好方法。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装qemu</span></span><br><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure><h2 id="安装编译busybox"><a href="#安装编译busybox" class="headerlink" title="安装编译busybox"></a>安装编译busybox</h2><p>安装busybox的目的是：借助BusyBox构建极简initramfs，提供基本的用户态可执行程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2  <span class="comment"># 去官网找最新版</span></span><br><span class="line">tar -xvf busybox-1.36.1.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.36.1/</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>在编译busybox之前，我们需要对其进行设置，执行<code>make menuconfig</code>，如下</p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201135953.png" alt="image-20231120113536905"></p><p><img src="https://raw.githubusercontent.com/wfloveiu/blogImage/main/img/202311201136740.png" alt="image-20231120113608696"></p><p>这里一定要选择<strong>静态编译</strong>，编译好的可执行文件<code>busybox</code>不依赖动态链接库，可以独立运行，方便构建initramfs。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j 8</span><br><span class="line">make &amp;&amp; make install <span class="comment"># 安装完成后生成的相关文件会在 _install 目录下</span></span><br></pre></td></tr></table></figure><h2 id="构建initramfs根文件系统"><a href="#构建initramfs根文件系统" class="headerlink" title="构建initramfs根文件系统"></a>构建initramfs根文件系统</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在busybox压缩包的下载目录下,创建的该文件夹，该文件夹下有</span></span><br><span class="line"><span class="comment"># wufang@wufang:~/linux_kernel/kernel_compile$ ls</span></span><br><span class="line"><span class="comment"># busybox-1.36.1   busybox-1.36.1.tar.bz2   linux-5.14  linux-5.14.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> initramfs</span><br><span class="line"><span class="built_in">cd</span> initramfs</span><br><span class="line"><span class="built_in">cp</span> ../busybox-1.29.0/_install/* -rf ./ <span class="comment">#将_install文件夹下的所有文件复制到initramfs文件夹下</span></span><br><span class="line"><span class="built_in">mkdir</span> dev proc sys</span><br><span class="line">sudo <span class="built_in">cp</span> -a /dev/&#123;null,console,<span class="built_in">tty</span>,tty1,tty2,tty3,tty4&#125; dev/</span><br><span class="line"><span class="built_in">rm</span> -f linuxrc</span><br><span class="line">vim init</span><br></pre></td></tr></table></figure><p>添加如下代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/busybox sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#123;==DBG==&#125; INIT SCRIPT&quot;</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;&#123;==DBG==&#125; Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line"><span class="built_in">exec</span> /sbin/init</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x init 修改文件权限</span><br><span class="line"><span class="comment"># 完成后，initrams下有如下文件</span></span><br><span class="line"><span class="comment"># bin   dev   init  proc  sbin  sys   usr</span></span><br></pre></td></tr></table></figure><p><strong>打包initramfs</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.cpio.gz</span><br><span class="line"><span class="comment"># 此时在busybox压缩包的下载目录下，有如下文件</span></span><br><span class="line"><span class="comment"># busybox-1.36.1          initramfs               linux-5.14</span></span><br><span class="line"><span class="comment"># busybox-1.36.1.tar.bz2  initramfs.cpio.gz       linux-5.14.tar.gz</span></span><br></pre></td></tr></table></figure><h2 id="启动Qemu调试内核"><a href="#启动Qemu调试内核" class="headerlink" title="启动Qemu调试内核"></a>启动Qemu调试内核</h2><p>上述完成之后，就可以启动Qemu来调试内核了,启动代码如下（是一个指令）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./arch/x86/boot/bzImage -initrd ../initramfs.cpio.gz -append <span class="string">&quot;nokaslr console=ttyS0&quot;</span> -s -S -nographic</span><br></pre></td></tr></table></figure><ul><li><code>qemu-system-x86_64</code>：指定是x86，64位;</li><li><code>-kernel ./arch/x86/boot/bzImage</code>：指定启用的内核镜像；</li><li><code>-initrd ../initramfs.cpio.gz</code>：指定启动的内存文件系统</li><li><code>-append &quot;nokaslr console=ttyS0&quot;</code> ：附加参数，其中 <code>nokaslr</code> 参数<strong>必须添加进来</strong>，防止内核起始地址随机化，这样会导致 gdb 断点不能命中；</li><li><code>-s</code> ：监听在 gdb 1234 端口；</li><li><code>-S</code> ：表示启动后就挂起，等待 gdb 连接；</li><li><code>-nographic</code>：不启动图形界面</li></ul><p>开启另一个命令行窗口，输入<strong>gdb</strong>，即可开启调试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote localhost:1234  <span class="comment">#连接qemu监听的端口</span></span><br><span class="line">(gdb) <span class="built_in">break</span> start_kernel      <span class="comment">#在start_kernel打断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span>  rest_init        <span class="comment">#在res_init打断点</span></span><br><span class="line">(gdb) c                       <span class="comment">#运行到断点处</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly中取消头像转动</title>
      <link href="/2023/11/18/hexo1/"/>
      <url>/2023/11/18/hexo1/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-Butterfly中鼠标放到头像上头像会转动，如何取消转动"><a href="#Hexo-Butterfly中鼠标放到头像上头像会转动，如何取消转动" class="headerlink" title="Hexo+Butterfly中鼠标放到头像上头像会转动，如何取消转动"></a>Hexo+Butterfly中鼠标放到头像上头像会转动，如何取消转动</h2><p>这个在_config中改不了，经过查阅资料，发现在 hexo-theme-butterfly&#x2F;source&#x2F;css&#x2F;_layout&#x2F;aside.styl中进行更改,大约在324行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img</span><br><span class="line">  width: 100%</span><br><span class="line">  height: 100%</span><br><span class="line">  transition: filter 375ms ease-in .2s, transform .3s</span><br><span class="line">  object-fit: cover</span><br><span class="line"></span><br><span class="line">  &amp;:hover</span><br><span class="line">    transform: rotate(360deg)</span><br></pre></td></tr></table></figure><p>将后两行删掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img</span><br><span class="line">  width: 100%</span><br><span class="line">  height: 100%</span><br><span class="line">  transition: filter 375ms ease-in .2s, transform .3s</span><br><span class="line">  object-fit: cover</span><br></pre></td></tr></table></figure><p>这样头像就不会转动了</p><p>参考链接: <a href="https://github.com/jerryc127/hexo-theme-butterfly/discussions/878">https://github.com/jerryc127/hexo-theme-butterfly/discussions/878</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 更改配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP算法模板</title>
      <link href="/2023/11/17/CSP2/"/>
      <url>/2023/11/17/CSP2/</url>
      
        <content type="html"><![CDATA[<h1 id="CSP算法"><a href="#CSP算法" class="headerlink" title="CSP算法"></a>CSP算法</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p><img src="C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20221229143608340.png" alt="image-20221229143608340"></p><p>第一类：ans是红色区间的右端点</p><p>​将[l,r]分成[l,m-1],[m,r]</p><p>​如果m是红色的，说明ans在[m,r]中</p><p>​如果m是绿色的，说明ans在[l,m-1]中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">m=(l+R+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> m 红的，l=m;</span><br><span class="line"><span class="keyword">else</span>      r=m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二类：ans是绿色区间的左端点</p><p>​将[l,r]分成[l,m],[m+1,r]</p><p>​如果m是绿色的，说明ans在[l,m]中</p><p>​如果m是红色的，说明ans在[m+1,r]中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">m=(l+R)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> m 绿的，r=m;</span><br><span class="line"><span class="keyword">else</span>      l=m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h3><p>将区间划分为[l,m],[m,r]</p><p>边界条件 r-l&gt;1e-6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">1e-6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>()  l=m;</span><br><span class="line">    <span class="keyword">else</span>  r=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N];   <span class="comment">// 表示原数组</span></span><br><span class="line"><span class="type">int</span> s[N];   <span class="comment">// 表示前缀和数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N][N];<span class="comment">//原数组</span></span><br><span class="line"><span class="type">int</span> s[N][N];<span class="comment">//前缀和数组,s[i][j]表示从(1,1)到(i,j)的和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">while</span> (q -- )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;<span class="comment">//(x1,y1)为左上角坐标，(x2,y2)为右上角坐标</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>每个操作包含三个整数 l,r,c,表示将序列中 [l,r] 之间的每个数加上 c。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span> <span class="comment">//差分计算的核心,在区间l到r间的每个数都加上c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[l] += c;</span><br><span class="line">    a[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">cf</span>(i, i, x); <span class="comment">//在i到i区间上的每个数都加上x，只是这个区间的长度为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//区间更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, x;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">        <span class="built_in">cf</span>(l, r, x); <span class="comment">//区间从l到r</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>]; <span class="comment">//这里并没有新开数组</span></span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>n个物品，v容量的背包，wi， vi 每件物品最多用1次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], n, m, f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//n件物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= w[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + v[i]); <span class="comment">//max中的f[j]是前一行即i-1行的f[j],f[j-w[i]]是i-1行的，满足要求</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>物品的个数没有限制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素做法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], n, m, f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//n件物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[i])</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], n, m, f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//n件物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = w[i]; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + v[i]); <span class="comment">//max中的f[j]是前一行即i-1行的f[j],f[j-w[i]]是i行的，满足要求</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>每个物品最多放入的数量都有限制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N], v[N], s[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//前n个物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = f[j]; <span class="comment">//当一个也不选i的时候，f[i][j]=f[i-1][j],这里把i-1行的j赋值给i行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i] &amp;&amp; k * w[i] &lt;= j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - k * w[i]] + k * v[i]); <span class="comment">//因为j是从大到小，所以这里的f[j-k*w[i]]是第i-1行的                                                                 对应数值，f[j]是第i行的，满足条件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><h3 id="收集卡牌"><a href="#收集卡牌" class="headerlink" title="收集卡牌"></a>收集卡牌</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">16</span>, M = <span class="number">1</span> &lt;&lt; N; <span class="comment">//状态压缩，M为16种卡牌情况对应的二进制数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">double</span> p[N];            <span class="comment">//概率</span></span><br><span class="line"><span class="type">double</span> f[M][N * <span class="number">5</span> + <span class="number">1</span>]; <span class="comment">//,i表示当前16个卡牌情况对应的二进制数，j为当前的硬币数,f[i][j]表示其期望期望抽卡次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> coins, <span class="type">int</span> r)</span> <span class="comment">//r表示还剩几张卡片未抽中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[state][coins] &gt;= <span class="number">0</span>) <span class="comment">//搜索过了</span></span><br><span class="line">        <span class="keyword">return</span> f[state][coins];</span><br><span class="line">    <span class="keyword">if</span> (coins &gt;= r * m)</span><br><span class="line">        <span class="keyword">return</span> f[state][coins] = <span class="number">0</span>; <span class="comment">//这种情况还需抽卡次数为0</span></span><br><span class="line">    <span class="type">double</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设抽到编号i的卡牌</span></span><br><span class="line">        <span class="keyword">if</span> (state &gt;&gt; i &amp; <span class="number">1</span>)<span class="comment">//判断第i位是不是1，是1，则之前抽到过</span></span><br><span class="line">            v += p[i] * (<span class="built_in">dp</span>(state, coins + <span class="number">1</span>, r) + <span class="number">1</span>); <span class="comment">//多了一个硬币</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v += p[i] * (<span class="built_in">dp</span>(state | (<span class="number">1</span> &lt;&lt; i), coins, r - <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">//state对应i位变为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[state][coins] = v; <span class="comment">//返回从这种状态到最后抽卡完成还需进行的抽卡次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N * <span class="number">5</span> + <span class="number">1</span>; j++)</span><br><span class="line">            f[i][j] = <span class="number">-1.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, <span class="built_in">dp</span>(<span class="number">0</span>, <span class="number">0</span>, n));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// #define x first;</span></span><br><span class="line"><span class="comment">// #define y second;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> T, r, c;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dis[N][N]; <span class="comment">//表示(i,j)到起点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(PII start, PII end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化距离数组</span></span><br><span class="line">    queue&lt;PII&gt; q; <span class="comment">//创建一个存放pair类型的队列</span></span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span> dis);<span class="comment">//初始化距离，-1表示不可达</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);<span class="comment">//该点是否被访问过</span></span><br><span class="line">    dis[start.first][start.second] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start); <span class="comment">//start入队列</span></span><br><span class="line">    st[start.first][start.second] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) <span class="comment">//当q非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>(); <span class="comment">//取队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            <span class="comment">//没有超过边界，未被访问，该点可以走(不是不可走点)</span></span><br><span class="line">            <span class="keyword">if</span> (g[x][y] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; !st[x][y] &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt; r &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; c)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                st[x][y] = <span class="literal">true</span>;</span><br><span class="line">                dis[x][y] = dis[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (end == <span class="built_in">make_pair</span>(x, y))</span><br><span class="line">                    <span class="keyword">return</span> dis[x][y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">            cin &gt;&gt; g[i];</span><br><span class="line">        <span class="comment">//找到开始和结束坐标</span></span><br><span class="line">        PII start, end;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                    start = &#123;i, j&#125;; <span class="comment">//pair的赋值方式</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">                    end = &#123;i, j&#125;;</span><br><span class="line">        <span class="type">int</span> distance = <span class="built_in">bfs</span>(start, end);<span class="comment">//找到从strat到end的最短距离</span></span><br><span class="line">        <span class="keyword">if</span> (distance == <span class="number">-1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;oop!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; distance &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(l, mid), <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt; q[j]) w[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> w[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) w[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) w[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = w[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 最大公约数</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line">#最小公倍数</span><br><span class="line">所有数相乘除以最大公约数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP基础</title>
      <link href="/2023/11/16/CSP1/"/>
      <url>/2023/11/16/CSP1/</url>
      
        <content type="html"><![CDATA[<h1 id="CSP基础"><a href="#CSP基础" class="headerlink" title="CSP基础"></a>CSP基础</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;iostream&gt;</span><br><span class="line">&lt;cstdio&gt;</span><br><span class="line">&lt;cstring&gt;</span><br><span class="line">&lt;algorithm&gt;</span><br><span class="line">&lt;vector&gt;</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;map&gt;</span><br><span class="line">&lt;cmath&gt;</span><br></pre></td></tr></table></figure><h2 id="定义常量和long-long"><a href="#定义常量和long-long" class="headerlink" title="定义常量和long long"></a>定义常量和long long</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line">结构体数组</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&#125;node[N];</span><br><span class="line">为结构体赋值时，直接用&#123;a,b,c&#125;就可以</span><br></pre></td></tr></table></figure><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">operator</span>+=   s1+=s2</span><br><span class="line"><span class="number">2.</span> compare <span class="keyword">operator</span>  两个string类型可以直接使用==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则是字典序</span><br><span class="line"><span class="number">3.</span> <span class="built_in">length</span>()/<span class="built_in">size</span>()</span><br><span class="line"><span class="number">4.</span> <span class="built_in">clear</span>()     <span class="built_in">clear</span>()用以清空string中的数据，时间复杂度一般为<span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">5.</span> <span class="built_in">substr</span>()  <span class="built_in">substr</span>(pos,len)，返回从pos号位置开始、长度为len的子串，时间复杂度为<span class="built_in">O</span>(len)</span><br><span class="line">     下标从<span class="number">0</span>开始</span><br><span class="line"><span class="number">6.</span> str.<span class="built_in">replace</span>(pos,len,str2)，把str从pos号位置开始，长度为len的子串替换为str2</span><br><span class="line"><span class="number">7.</span> find：从前往后查找子串或字符出现的位置。</span><br><span class="line"><span class="number">8.</span> rfind：从后往前查找子串或字符出现的位置。</span><br><span class="line"><span class="number">9.</span> find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：</span><br><span class="line"><span class="number">10.</span> s1.<span class="built_in">find_first_of</span>(<span class="string">&quot;abc&quot;</span>); 查找s1中第一次出现<span class="string">&quot;abc&quot;</span>中任一字符的位置</span><br><span class="line"><span class="number">11.</span> find_last_of：从后往前查找何处出现另一个字符串中包含的字符。</span><br><span class="line"><span class="number">12.</span> find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。</span><br><span class="line"><span class="number">13.</span> find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector 可以直接赋值</span><br><span class="line"><span class="number">1.</span>头文件  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="number">2.</span>创建对象 vector&lt;<span class="keyword">typename</span>&gt; v</span><br><span class="line"><span class="number">3.</span>增：v.<span class="built_in">push_back</span>(k)   在末尾添加k</span><br><span class="line">     v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>()+i,k)  让k插入到第i+<span class="number">1</span>的位置</span><br><span class="line">  删：删除给定位置元素：v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>()+<span class="number">2</span>)-----删除第三个元素</span><br><span class="line">      v.<span class="built_in">pop_back</span>()  删除最后的元素</span><br><span class="line">  查：按下标查：<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)</span><br><span class="line">     按迭代器查：<span class="keyword">for</span>(vector&lt;<span class="keyword">typename</span>&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)-----it为指针</span><br><span class="line">v.<span class="built_in">size</span>()   大小</span><br><span class="line">v.<span class="built_in">clear</span>()  清空</span><br><span class="line">v.<span class="built_in">empty</span>()  判空</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  增： s.<span class="built_in">insert</span>(k) 插入k</span><br><span class="line">  删：s.<span class="built_in">erase</span>(k)  删除k</span><br><span class="line">  查：s.<span class="built_in">find</span>(k) 返回k的定位器，没有就返回s.<span class="built_in">end</span>()</span><br><span class="line">      s.<span class="built_in">count</span>(k)  查询k出现的次数 <span class="number">0</span>/<span class="number">1</span></span><br><span class="line">      定位器进行遍历</span><br><span class="line"><span class="built_in">lower_bound</span>(key_value) ，返回第一个大于等于key_value的定位器</span><br><span class="line"><span class="built_in">upper_bound</span>(key_value)，返回最后一个大于等于key_value的定位器</span><br><span class="line">s.<span class="built_in">size</span>()   大小</span><br><span class="line">s.<span class="built_in">clear</span>()  清空</span><br><span class="line">s.<span class="built_in">empty</span>()  判空</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>由于set元素是排好序的，且默认为升序，因此当set集合中的元素为结构体或自定义类时，该结构体或自定义类必须实现运算符‘&lt;’的重载。</strong></p><p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">声明map&lt;<span class="type">int</span>,string&gt; m;</span><br><span class="line">增：用下标：map[<span class="number">123</span>]=<span class="string">&quot;oapsopa&quot;</span>  建立key=<span class="number">123</span>，value的映射，如果存在<span class="number">123</span>与其它的映射，则修改为该映射  </span><br><span class="line">   insert:  map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(i,j))</span><br><span class="line">   删：map.<span class="built_in">erase</span>(k) 删除k对应的键值对</span><br><span class="line">   查：map.<span class="built_in">find</span>(k)  该函数返回的是指向该元素的迭代器。</span><br><span class="line">       map.<span class="built_in">count</span>(k)  该函数返回的是k出现的次数</span><br><span class="line">map.<span class="built_in">size</span>()   大小</span><br><span class="line">map.<span class="built_in">clear</span>()  清空</span><br><span class="line">map.<span class="built_in">empty</span>()  判空</span><br><span class="line">map中的元素是自动按Key升序排序，所以不能对map用sort函数；</span><br><span class="line"></span><br><span class="line">map和multimap都需要<span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span>，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。</span></span><br></pre></td></tr></table></figure><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p><strong>string转换为数字</strong></p><p>int i &#x3D; stoi(s1) string转换成整型数字  “123”à123</p><p>long l &#x3D;stol(s1)  string转换成长整型 </p><p>long l &#x3D;stol(s1)  string转换成长整型</p><p>float f&#x3D;stof(s2)  string转换成浮点型</p><p>double d &#x3D; stod(s2) </p><p><strong>string 转 char</strong>*</p><p>string str &#x3D; “hello”;</p><p>const char *p &#x3D; str.c_str(); 返回字符数组的指针</p><p><strong>char[] 转 string</strong></p><p>直接赋值</p><p><strong>数字转换成string</strong></p><p>to_string(i) 这里的i可以是整形，长整型，浮点型</p><p><strong>大小写字母转换</strong></p><p>tolower(‘A’) 大写-&gt;小写</p><p>toupper(‘a’) 小写-&gt;大写</p><h2 id="数据读入读出"><a href="#数据读入读出" class="headerlink" title="数据读入读出"></a>数据读入读出</h2><h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用cin，在碰到空格和换行符时，结束这个字符串的输入，</span><br><span class="line">使用cin.getline()接受一个字符串，可以接收空格。</span><br><span class="line">如：</span><br><span class="line">    char m[20]; </span><br><span class="line">    cin.getline(m,5);</span><br><span class="line">这里的接受值只能是字符数组，不能是string类型的字符串</span><br><span class="line">使用getline()接受一个字符串，可以接收空格并输出</span><br><span class="line">如:</span><br><span class="line">string str; </span><br><span class="line">getline(cin,str); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="特殊1：知道有几行数据要读入，但是一行数据中不知道有多少个"><a href="#特殊1：知道有几行数据要读入，但是一行数据中不知道有多少个" class="headerlink" title="特殊1：知道有几行数据要读入，但是一行数据中不知道有多少个"></a>特殊1：知道有几行数据要读入，但是一行数据中不知道有多少个</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用sstream头文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);<span class="comment">//第一行的换行符</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; line;</span></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);      <span class="comment">//cin表示输入流，line表示存储输入流的信息，默认情况下                                       stringstream        ssin(line); //从line中读取字符串，作为输入</span></span><br><span class="line">        <span class="keyword">while</span> (ssin &gt;&gt; a[n])</span><br><span class="line">            n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="特殊2：日期问题"><a href="#特殊2：日期问题" class="headerlink" title="特殊2：日期问题"></a>特殊2：日期问题</h3><p>例如这种数据</p><p><img src="C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20230304180010547.png" alt="image-20230304180010547"></p><p>需要在输入数据的时候就转换成整形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsecond</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> day_s = <span class="number">24</span> * <span class="number">3600</span>; <span class="comment">//一天的秒数</span></span><br><span class="line">    <span class="keyword">return</span> day_s * d + h * <span class="number">3600</span> + m * <span class="number">60</span> + s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入是一整行字符。并且有空格，需要用getline</span></span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">back</span>() != <span class="string">&#x27;)&#x27;</span>) <span class="comment">//使用的编译版本没有这个函数</span></span><br><span class="line">        line += <span class="string">&quot;(+0)&quot;</span>;</span><br><span class="line">    <span class="type">int</span> h1, m1, s1, h2, m2, s2, d;</span><br><span class="line">    <span class="built_in">sscanf</span>(line.<span class="built_in">c_str</span>(), <span class="string">&quot;%d:%d:%d %d:%d:%d (+%d)&quot;</span>, &amp;h1, &amp;m1, &amp;s1, &amp;h2, &amp;m2, &amp;s2, &amp;d);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getsecond</span>(d, h2, m2, s2) - <span class="built_in">getsecond</span>(<span class="number">0</span>, h1, m1, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cmath"><a href="#cmath" class="headerlink" title="cmath"></a>cmath</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">cmath包含了许多数学函数,非常实用</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、 三角函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sin</span><span class="params">(<span class="type">double</span>)</span></span>;正弦</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cos</span><span class="params">(<span class="type">double</span>)</span></span>;余弦</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">tan</span><span class="params">(<span class="type">double</span>)</span></span>;正切</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 、反三角函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">asin</span> <span class="params">(<span class="type">double</span>)</span></span>; 结果介于[-PI/<span class="number">2</span>,PI/<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">acos</span> <span class="params">(<span class="type">double</span>)</span></span>; 结果介于[<span class="number">0</span>,PI]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">atan</span> <span class="params">(<span class="type">double</span>)</span></span>; 反正切（主值），结果介于[-PI/<span class="number">2</span>,PI/<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">atan2</span> <span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>; 反正切（整圆值），结果介于[-PI,PI]</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 、双曲三角函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sinh</span> <span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cosh</span> <span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">tanh</span> <span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 、指数与对数</span><br><span class="line"></span><br><span class="line">没有以任意为底数的对数函数,可以用<span class="built_in">logx</span>(y)=<span class="built_in">log</span>(y)/<span class="built_in">log</span>(x)来代替</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="built_in">log</span> (<span class="type">double</span>); 以e为底的对数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">log10</span> <span class="params">(<span class="type">double</span>)</span></span>;以<span class="number">10</span>为底的对数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span>;计算x的y次幂<span class="comment">//不精准</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">powf</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y)</span></span>; 功能与pow一致，只是输入与输出皆为单精度浮点数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">exp</span> <span class="params">(<span class="type">double</span>)</span></span>;求取自然数e的幂</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span> <span class="params">(<span class="type">double</span>)</span></span>;开平方根</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> 、取整</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ceil</span> <span class="params">(<span class="type">double</span>)</span></span>; 取上整，返回不比x小的最小整数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">floor</span> <span class="params">(<span class="type">double</span>)</span></span>; 取下整，返回不比x大的最大整数，即高斯函数[x]</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> 、绝对值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span> <span class="params">(<span class="type">double</span>)</span></span>;求实型的绝对值</span><br></pre></td></tr></table></figure><h2 id="闰年"><a href="#闰年" class="headerlink" title="闰年"></a>闰年</h2><p>1）四年一闰百年不闰：即如果year能够被4整除，但是不能被100整除，则year是闰年。 </p><p>2）每四百年再一闰：如果year能够被400整除，则year是闰年。</p><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">answer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y, m, d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> answer &amp;p) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y != p.y)</span><br><span class="line">            <span class="keyword">return</span> y &lt; p.y;</span><br><span class="line">        <span class="keyword">if</span> (m != p.m)</span><br><span class="line">            <span class="keyword">return</span> m &lt; p.m;</span><br><span class="line">        <span class="keyword">return</span> d &lt; p.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ans[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
